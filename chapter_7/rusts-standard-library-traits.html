<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>【完整】Rust 标准库 Trait 指南 - Rust精选</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The roots aren&#x27;t deep but the seeds are planted!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">RustMagazine 中文月刊</li><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item "><a href="../send_word.html"><strong aria-hidden="true">2.</strong> 创刊寄语</a></li><li class="chapter-item affix "><li class="part-title">2021 年期刊</li><li class="chapter-item "><a href="../chapter_1/toc.html"><strong aria-hidden="true">3.</strong> 一月刊（January）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_1/lang.html"><strong aria-hidden="true">3.1.</strong> 本月简报 | Rust官方动态</a></li><li class="chapter-item "><a href="../chapter_1/hots.html"><strong aria-hidden="true">3.2.</strong> 本月简报 |社区热点</a></li><li class="chapter-item "><a href="../chapter_1/projects.html"><strong aria-hidden="true">3.3.</strong> 本月简报 | 推荐项目</a></li><li class="chapter-item "><a href="../chapter_1/learns.html"><strong aria-hidden="true">3.4.</strong> 本月简报 | 学习资源</a></li><li class="chapter-item "><a href="../chapter_1/rust_laoke.html"><strong aria-hidden="true">3.5.</strong> 本月简报 | Rust唠嗑室本月汇总</a></li><li class="chapter-item "><a href="../chapter_1/jit.html"><strong aria-hidden="true">3.6.</strong> RustChinaConf2020 精选 | 用Rust设计高性能JIT执行引擎</a></li><li class="chapter-item "><a href="../chapter_1/rust_async.html"><strong aria-hidden="true">3.7.</strong> RustChinaConf2020 精选 | Rust 异步与并发</a></li><li class="chapter-item "><a href="../chapter_1/1password.html"><strong aria-hidden="true">3.8.</strong> 生产实践 |「译」1password 的 Rust 实践</a></li><li class="chapter-item "><a href="../chapter_1/cita_protobuf-ext.html"><strong aria-hidden="true">3.9.</strong> 生产实践 | 溪塔科技: 用Rust写Protobuf扩展</a></li><li class="chapter-item "><a href="../chapter_1/rust-design-patterns/builder.html"><strong aria-hidden="true">3.10.</strong> 学习园地 | 「系列」Rust设计模式之创建者模式</a></li><li class="chapter-item "><a href="../chapter_1/io_uring_and_rust.html"><strong aria-hidden="true">3.11.</strong> 学习园地 | 关于 io_uring 与 Rust 的思考</a></li><li class="chapter-item "><a href="../chapter_1/graphql_in_rust/graphql_in_rust.html"><strong aria-hidden="true">3.12.</strong> 学习园地 | 「译」 GraphQL in Rust</a></li><li class="chapter-item "><a href="../chapter_1/rust_ownership.html"><strong aria-hidden="true">3.13.</strong> 学习园地 | 图解 Rust 所有权与生命周期</a></li><li class="chapter-item "><a href="../chapter_1/embedded_rust.html"><strong aria-hidden="true">3.14.</strong> 嵌入式领域的Rust语言</a></li><li class="chapter-item "><a href="../chapter_1/rcore_intro.html"><strong aria-hidden="true">3.15.</strong> 用Rust写操作系统 | rCore OS 教程介绍 </a></li><li class="chapter-item "><a href="../chapter_1/rust_security_part1.html"><strong aria-hidden="true">3.16.</strong> Rust Security 专题 | Rust生态安全漏洞总结系列 | Part 1</a></li><li class="chapter-item "><a href="../chapter_1/rustc_dev_guide_zh.html"><strong aria-hidden="true">3.17.</strong> Rust编译器专题 | Rust Dev Guide 中文翻译启动招募</a></li><li class="chapter-item "><a href="../chapter_1/rustc_part1.html"><strong aria-hidden="true">3.18.</strong> Rust编译器专题 | 图解 Rust 编译器与语言设计 Part 1</a></li></ol></li><li class="chapter-item "><a href="../chapter_2/toc.html"><strong aria-hidden="true">4.</strong> 二月刊（February）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_2/announce.html"><strong aria-hidden="true">4.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_2/lang.html"><strong aria-hidden="true">4.2.</strong> 本月简报 | Rust官方动态</a></li><li class="chapter-item "><a href="../chapter_2/hots.html"><strong aria-hidden="true">4.3.</strong> 本月简报 |社区热点</a></li><li class="chapter-item "><a href="../chapter_2/projects.html"><strong aria-hidden="true">4.4.</strong> 本月简报 | 推荐项目</a></li><li class="chapter-item "><a href="../chapter_2/learns.html"><strong aria-hidden="true">4.5.</strong> 本月简报 | 学习资源</a></li><li class="chapter-item "><a href="../chapter_2/rust_laoke.html"><strong aria-hidden="true">4.6.</strong> 本月简报 | Rust唠嗑室本月汇总</a></li><li class="chapter-item "><a href="../chapter_2/rust_zhihu.html"><strong aria-hidden="true">4.7.</strong> 知乎 Rust 圆桌年话专题问答精选</a></li><li class="chapter-item "><a href="../chapter_2/huawei_rust.html"><strong aria-hidden="true">4.8.</strong> 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景</a></li><li class="chapter-item "><a href="../chapter_2/rust_trace.html"><strong aria-hidden="true">4.9.</strong> PingCAP | TiKV 高性能追踪的实现解析</a></li><li class="chapter-item "><a href="../chapter_2/rust_error_handle.html"><strong aria-hidden="true">4.10.</strong> 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考</a></li><li class="chapter-item "><a href="../chapter_2/rust_error_handle_and_log.html"><strong aria-hidden="true">4.11.</strong> 华为 | Rust中的错误传递和日志记录</a></li><li class="chapter-item "><a href="../chapter_2/rust_study.html"><strong aria-hidden="true">4.12.</strong> 新年新人新气象 | Rust 学习笔记</a></li><li class="chapter-item "><a href="../chapter_2/cli_gameoflife.html"><strong aria-hidden="true">4.13.</strong> 「译」使用 Rust 实现命令行生命游戏</a></li><li class="chapter-item "><a href="../chapter_2/actor_with_tokio.html"><strong aria-hidden="true">4.14.</strong> 「译」使用 Tokio 实现 Actor 系统</a></li><li class="chapter-item "><a href="../chapter_2/rust_1.50.html"><strong aria-hidden="true">4.15.</strong> 解读 Rust 1.50 稳定版</a></li><li class="chapter-item "><a href="../chapter_2/rust_2021_edition.html"><strong aria-hidden="true">4.16.</strong> 解读 Rust 2021 Edition RFC </a></li><li class="chapter-item "><a href="../chapter_2/rust_wasm_frontend.html"><strong aria-hidden="true">4.17.</strong> 前端入门 ｜ Rust 和 WebAssembly </a></li><li class="chapter-item "><a href="../chapter_2/rust_game_bevy_bomber.html"><strong aria-hidden="true">4.18.</strong> 实践案例 | 使用 Bevy 游戏引擎制作炸弹人</a></li><li class="chapter-item "><a href="../chapter_2/io_uring_intro.html"><strong aria-hidden="true">4.19.</strong> io_uring | Linux 全新异步接口 io_uring 的 Rust 生态盘点 </a></li><li class="chapter-item "><a href="../chapter_2/io_uring_async_rw.html"><strong aria-hidden="true">4.20.</strong> io_uring | 用 Rust 实现基于 io_uring 的异步随机读文件</a></li><li class="chapter-item "><a href="../chapter_2/contribute_to_the_rust_part1.html"><strong aria-hidden="true">4.21.</strong> 如何为 Rust 语言做贡献 | Part 1</a></li></ol></li><li class="chapter-item "><a href="../chapter_3/toc.html"><strong aria-hidden="true">5.</strong> 三月刊（March）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_3/announce.html"><strong aria-hidden="true">5.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_3/lang.html"><strong aria-hidden="true">5.2.</strong> Rust官方动态</a></li><li class="chapter-item "><a href="../chapter_3/hots.html"><strong aria-hidden="true">5.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_3/projects.html"><strong aria-hidden="true">5.4.</strong> 推荐项目</a></li><li class="chapter-item "><a href="../chapter_3/learns.html"><strong aria-hidden="true">5.5.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_3/rust_laoke.html"><strong aria-hidden="true">5.6.</strong> Rust 唠嗑室本月汇总</a></li><li class="chapter-item "><a href="../chapter_3/hw_rust_stratovirt.html"><strong aria-hidden="true">5.7.</strong> 华为 | 基于Rust的下一代虚拟化平台-StratoVirt</a></li><li class="chapter-item "><a href="../chapter_3/hw_ndarray.html"><strong aria-hidden="true">5.8.</strong> 华为 | Rust 科学计算多维数组运算库的分析与实践</a></li><li class="chapter-item "><a href="../chapter_3/hw_rust_rvm_wasm_ai.html"><strong aria-hidden="true">5.9.</strong> 华为 | 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型</a></li><li class="chapter-item "><a href="../chapter_3/rust_cpu_affinity.html"><strong aria-hidden="true">5.10.</strong> 蚂蚁集团 CeresDB 团队 | Rust CPU Affinity 初探</a></li><li class="chapter-item "><a href="../chapter_3/rust_rdma.html"><strong aria-hidden="true">5.11.</strong> DatenLord | Rust实现RDMA</a></li><li class="chapter-item "><a href="../chapter_3/async-vision-doc.html"><strong aria-hidden="true">5.12.</strong> 建立 Async Rust 的共同愿景</a></li><li class="chapter-item "><a href="../chapter_3/how-our-aws-rust-team-will-contribute-to-rusts-future-successes.html"><strong aria-hidden="true">5.13.</strong> Niko | 我们的 AWS Rust 团队将如何为 Rust 未来的成功做出贡献</a></li><li class="chapter-item "><a href="../chapter_3/no_std_binary.html"><strong aria-hidden="true">5.14.</strong> no_std 环境下的可执行文件</a></li><li class="chapter-item "><a href="../chapter_3/ink.html"><strong aria-hidden="true">5.15.</strong> 用 Rust 写智能合约 | Hello, Ink!  </a></li><li class="chapter-item "><a href="../chapter_3/reservoir.html"><strong aria-hidden="true">5.16.</strong> 「算法」蓄水池算法改进 - 面向抽奖场景保证等概率性</a></li><li class="chapter-item "><a href="../chapter_3/rust-mysql.html"><strong aria-hidden="true">5.17.</strong> Rust中使用MySQL</a></li><li class="chapter-item "><a href="../chapter_3/rust-design-pattern-factory.html"><strong aria-hidden="true">5.18.</strong> 「系列」Rust设计模式 ｜ 工厂模式</a></li><li class="chapter-item "><a href="../chapter_3/rust_vs_pandas.html"><strong aria-hidden="true">5.19.</strong> 「译」数据操作：Rust vs Pandas</a></li><li class="chapter-item "><a href="../chapter_3/Unsafe_Rust_How_and_when_not_to_use_it.html"><strong aria-hidden="true">5.20.</strong> 「译」Unsafe Rust 的取舍</a></li><li class="chapter-item "><a href="../chapter_3/Rhythm-game-in-Rust-using-bevy.html"><strong aria-hidden="true">5.21.</strong> 「译」基于 Rust 用 Bevy 实现节奏大师游戏</a></li><li class="chapter-item "><a href="../chapter_3/arenas-in-rust.html"><strong aria-hidden="true">5.22.</strong> 「译」Arenas in Rust</a></li><li class="chapter-item "><a href="../chapter_3/toy-front-end-for-llvm-write-in-rust.html"><strong aria-hidden="true">5.23.</strong> 「译」用 Rust 编写 LLVM 的玩具编译器</a></li><li class="chapter-item "><a href="../chapter_3/rust-to-system-essence-concurrent.html"><strong aria-hidden="true">5.24.</strong> 透过 Rust 探索系统的本原：并发篇</a></li><li class="chapter-item "><a href="../chapter_3/rust-to-system-essence-safety.html"><strong aria-hidden="true">5.25.</strong> 透过 Rust 探索系统的本原：安全篇</a></li><li class="chapter-item "><a href="../chapter_3/contribute_to_the_rust_part2.html"><strong aria-hidden="true">5.26.</strong> 如何为 Rust 语言做贡献 | Part 2</a></li></ol></li><li class="chapter-item "><a href="../chapter_4/toc.html"><strong aria-hidden="true">6.</strong> 四月刊（April）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_4/announce.html"><strong aria-hidden="true">6.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_4/info.html"><strong aria-hidden="true">6.2.</strong> Rust 资讯来源汇总</a></li><li class="chapter-item "><a href="../chapter_4/lang.html"><strong aria-hidden="true">6.3.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_4/hots.html"><strong aria-hidden="true">6.4.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_4/events.html"><strong aria-hidden="true">6.5.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_4/jobs.html"><strong aria-hidden="true">6.6.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_4/safe_system.html"><strong aria-hidden="true">6.7.</strong> 论文鉴赏 | 使用 Rust 进行安全系统编程</a></li><li class="chapter-item "><a href="../chapter_4/safe_drop.html"><strong aria-hidden="true">6.8.</strong> 论文鉴赏 | SafeDrop：通过静态数据流分析检测Rust程序的内存释放错误</a></li><li class="chapter-item "><a href="../chapter_4/event_os_design.html"><strong aria-hidden="true">6.9.</strong> 学界动态</a></li><li class="chapter-item "><a href="../chapter_4/hw_stratovirt.html"><strong aria-hidden="true">6.10.</strong> 华为 | StratoVirt 地址空间管理-基于Rust的实现与优化</a></li><li class="chapter-item "><a href="../chapter_4/hw_bin_opt.html"><strong aria-hidden="true">6.11.</strong> 华为 | Rust 编译后二进制大小和常用优化方式</a></li><li class="chapter-item "><a href="../chapter_4/ant_async_os_opt.html"><strong aria-hidden="true">6.12.</strong> 蚂蚁集团 | 异步化OS：利用Rustasyncawait提升10x性能-Rust</a></li><li class="chapter-item "><a href="../chapter_4/ant_trait.html"><strong aria-hidden="true">6.13.</strong> 蚂蚁集团 | Trait 使用及实现分析</a></li><li class="chapter-item "><a href="../chapter_4/zhihu_simd_rucene.html"><strong aria-hidden="true">6.14.</strong> 知乎 | 基于 SIMD 指令优化 Rucene</a></li><li class="chapter-item "><a href="../chapter_4/datenlord_io_uring.html"><strong aria-hidden="true">6.15.</strong> Datenlord | Rust 异步实现 io_uring </a></li><li class="chapter-item "><a href="../chapter_4/rust_ffi.html"><strong aria-hidden="true">6.16.</strong> PingCAP | 使用 Rust FFI </a></li><li class="chapter-item "><a href="../chapter_4/libp2p_ipfs.html"><strong aria-hidden="true">6.17.</strong> Netwarp | libp2p-rs与IPFS-Rust </a></li><li class="chapter-item "><a href="../chapter_4/google_android_rust.html"><strong aria-hidden="true">6.18.</strong> Google | 在 Android 平台使用 Rust</a></li><li class="chapter-item "><a href="../chapter_4/meili_search.html"><strong aria-hidden="true">6.19.</strong> MeiliSearch | 开源搜索引擎</a></li><li class="chapter-item "><a href="../chapter_4/learn.html"><strong aria-hidden="true">6.20.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_4/a-primer-on-rusts-result-type.html"><strong aria-hidden="true">6.21.</strong> 【译】Rust 的 Result 类型基础</a></li><li class="chapter-item "><a href="../chapter_4/faq.html"><strong aria-hidden="true">6.22.</strong> 常见问题汇总</a></li><li class="chapter-item "><a href="../chapter_4/tips.html"><strong aria-hidden="true">6.23.</strong> 语言技巧</a></li><li class="chapter-item "><a href="../chapter_4/try_trait_v2.html"><strong aria-hidden="true">6.24.</strong> RFC 介绍 | try-trait v2</a></li><li class="chapter-item "><a href="../chapter_4/2021_edition_preview.html"><strong aria-hidden="true">6.25.</strong> 【官宣】Rust 2021 Edition 计划</a></li><li class="chapter-item "><a href="../chapter_4/rustc_edit_distance_and_typo_checker.html"><strong aria-hidden="true">6.26.</strong> 用 rustc 源码实现拼写错误候选词建议</a></li><li class="chapter-item "><a href="../chapter_4/nom_url.html"><strong aria-hidden="true">6.27.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="../chapter_4/facade.html"><strong aria-hidden="true">6.28.</strong> 真实世界的设计模式 | 外观模式（Facade Pattern）</a></li><li class="chapter-item "><a href="../chapter_4/rust-to-system-essence-raii.html"><strong aria-hidden="true">6.29.</strong> Rust 探索系统本原 | RAII </a></li><li class="chapter-item "><a href="../chapter_4/rust-to-system-essence-lang.html"><strong aria-hidden="true">6.30.</strong> Rust 探索系统本原 | 编程语言 </a></li><li class="chapter-item "><a href="../chapter_4/rust-to-system-essence-memory.html"><strong aria-hidden="true">6.31.</strong> Rust 探索系统本原 | 内存管理 </a></li><li class="chapter-item "><a href="../chapter_4/rust-to-system-essence-network.html"><strong aria-hidden="true">6.32.</strong> Rust 探索系统本原 | 网络 </a></li><li class="chapter-item "><a href="../chapter_4/contribute_to_the_rust_part3.html"><strong aria-hidden="true">6.33.</strong> 如何为 Rust 语言做贡献 | Part 3 </a></li><li class="chapter-item "><a href="../chapter_4/improve-std-slice-binary-search.html"><strong aria-hidden="true">6.34.</strong> 优化 Rust 标准库的 binary_search</a></li><li class="chapter-item "><a href="../chapter_4/github_trending.html"><strong aria-hidden="true">6.35.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_4/tool_libs.html"><strong aria-hidden="true">6.36.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_4/frameworks.html"><strong aria-hidden="true">6.37.</strong> 推荐项目 |  框架引擎</a></li><li class="chapter-item "><a href="../chapter_4/tensorbase.html"><strong aria-hidden="true">6.38.</strong> 开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></li><li class="chapter-item "><a href="../chapter_4/zenoh.html"><strong aria-hidden="true">6.39.</strong> 开源产品 | eclipse zenoh 助力雾计算和边缘计算</a></li><li class="chapter-item "><a href="../chapter_4/unsafe_rust_tips.html"><strong aria-hidden="true">6.40.</strong> Unsafe Rust 编码技巧 | Part 1</a></li></ol></li><li class="chapter-item "><a href="../chapter_5/toc.html"><strong aria-hidden="true">7.</strong> 五月刊（May）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_5/announce.html"><strong aria-hidden="true">7.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_5/lang.html"><strong aria-hidden="true">7.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_5/hots.html"><strong aria-hidden="true">7.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_5/events.html"><strong aria-hidden="true">7.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_5/jobs.html"><strong aria-hidden="true">7.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_5/six-years-of-rust.html"><strong aria-hidden="true">7.6.</strong> 官方 | Rust 发布六周年</a></li><li class="chapter-item "><a href="../chapter_5/rusts-most-unrecognized-contributor.html"><strong aria-hidden="true">7.7.</strong> Rust 贡献名单上的无名英雄</a></li><li class="chapter-item "><a href="../chapter_5/pl.html"><strong aria-hidden="true">7.8.</strong> 漫谈编程语言的设计和实现</a></li><li class="chapter-item "><a href="../chapter_5/hw_StratoVirt_vcpu.html"><strong aria-hidden="true">7.9.</strong> 华为 | StratoVirt VCPU管理-Rust线程同步的实现</a></li><li class="chapter-item "><a href="../chapter_5/rust-memory-troubleshootting.html"><strong aria-hidden="true">7.10.</strong> 蚂蚁集团 ｜ 如何在生产环境排查 Rust 内存占用过高问题</a></li><li class="chapter-item "><a href="../chapter_5/rust-epoll-rdma.html"><strong aria-hidden="true">7.11.</strong> Datenlord | Rust实现RDMA异步编程（一）：基于epoll实现RDMA 异步操作</a></li><li class="chapter-item "><a href="../chapter_5/facebook_with_rust.html"><strong aria-hidden="true">7.12.</strong> Facebook | 应用 Rust 简史</a></li><li class="chapter-item "><a href="../chapter_5/rust_grpc_load_balancing.html"><strong aria-hidden="true">7.13.</strong> Truelayer | Rust 中的 gRPC 负载均衡</a></li><li class="chapter-item "><a href="../chapter_5/learn.html"><strong aria-hidden="true">7.14.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_5/Things_you_can_not_do_in_Rust.html"><strong aria-hidden="true">7.15.</strong> Rust 中无法办到的事情(以及如何替代)</a></li><li class="chapter-item "><a href="../chapter_5/proc_macro_workshop_guide_for_builder_project.html"><strong aria-hidden="true">7.16.</strong> Rust过程宏系列教程 | Proc Macro Workshop 之 Builder 实现</a></li><li class="chapter-item "><a href="../chapter_5/running_rust_on_android.html"><strong aria-hidden="true">7.17.</strong> 在 Android 中运行 Rust </a></li><li class="chapter-item "><a href="../chapter_5/ink_01.html"><strong aria-hidden="true">7.18.</strong> Rust 与 区块链 | ink! 编程实战（一）: 初识 ink!</a></li><li class="chapter-item "><a href="../chapter_5/faq.html"><strong aria-hidden="true">7.19.</strong> 常见问题汇总</a></li><li class="chapter-item "><a href="../chapter_5/tips.html"><strong aria-hidden="true">7.20.</strong> 语言技巧</a></li><li class="chapter-item "><a href="../chapter_5/rust-gat.html"><strong aria-hidden="true">7.21.</strong> 了解一点关于泛型关联类型(GAT)的事</a></li><li class="chapter-item "><a href="../chapter_5/rust-runtime-and-ABI.html"><strong aria-hidden="true">7.22.</strong> Rust Runtime 与 ABI</a></li><li class="chapter-item "><a href="../chapter_5/cache_and_recursion_memoization.html"><strong aria-hidden="true">7.23.</strong> 借鉴数据库缓存解决动态规划难题</a></li><li class="chapter-item "><a href="../chapter_5/kernel_huge_page_subsystem.html"><strong aria-hidden="true">7.24.</strong> Rust 与 OS | 一种有效的页表系统抽象设计</a></li><li class="chapter-item "><a href="../chapter_5/rpi_os.html"><strong aria-hidden="true">7.25.</strong> 学习笔记 ｜ 树莓派 Rust 嵌入式操作系统 之 驱动：GPIO 和 UART</a></li><li class="chapter-item "><a href="../chapter_5/rust-to-system-essence-lang-generic.html"><strong aria-hidden="true">7.26.</strong> 透过 Rust 探索系统的本原：泛型</a></li><li class="chapter-item "><a href="../chapter_5/github_trending.html"><strong aria-hidden="true">7.27.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_5/tool_libs.html"><strong aria-hidden="true">7.28.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_5/frameworks.html"><strong aria-hidden="true">7.29.</strong> 推荐项目 |  框架引擎</a></li><li class="chapter-item "><a href="../chapter_5/rust-security-part-2.html"><strong aria-hidden="true">7.30.</strong> Rust生态安全漏洞总结系列 | Part 2</a></li><li class="chapter-item "><a href="../chapter_5/rust-makes-malware-stronger.html"><strong aria-hidden="true">7.31.</strong> Rust 与 安全 | Rust 让恶意软件也变强了</a></li></ol></li><li class="chapter-item "><a href="../chapter_6/toc.html"><strong aria-hidden="true">8.</strong> 六月刊（June）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_6/announce.html"><strong aria-hidden="true">8.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_6/lang.html"><strong aria-hidden="true">8.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_6/hots.html"><strong aria-hidden="true">8.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_6/events.html"><strong aria-hidden="true">8.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_6/jobs.html"><strong aria-hidden="true">8.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_6/rust-not-a-company.html"><strong aria-hidden="true">8.6.</strong> Rust与开源 ｜ Rust 不是一家公司</a></li><li class="chapter-item "><a href="../chapter_6/open-source-mental-health.html"><strong aria-hidden="true">8.7.</strong> 开源与心理健康</a></li><li class="chapter-item "><a href="../chapter_6/rust-report.html"><strong aria-hidden="true">8.8.</strong> 三万言｜2021 年 Rust 行业调研报告</a></li><li class="chapter-item "><a href="../chapter_6/webassmebly-security.html"><strong aria-hidden="true">8.9.</strong> 华为 | WebAssembly 安全性调研</a></li><li class="chapter-item "><a href="../chapter_6/hw_StratoVirt_balloon.html"><strong aria-hidden="true">8.10.</strong> 华为 | StratoVirt - 基于Rust的 balloon 功能实践</a></li><li class="chapter-item "><a href="../chapter_6/ant-rust-data-layout.html"><strong aria-hidden="true">8.11.</strong> 蚂蚁集团 ｜ Rust 数据内存布局</a></li><li class="chapter-item "><a href="../chapter_6/rust-lockfree.html"><strong aria-hidden="true">8.12.</strong> Datenlord | Rust 语言无锁数据结构的内存管理</a></li><li class="chapter-item "><a href="../chapter_6/docker-wasm.html"><strong aria-hidden="true">8.13.</strong> SecondState | 用 Docker 工具管理 Rust 函数</a></li><li class="chapter-item "><a href="../chapter_6/custom-clippy.html"><strong aria-hidden="true">8.14.</strong> 华为 | 如何定制 Cargo Clippy </a></li><li class="chapter-item "><a href="../chapter_6/static_analysis_custom_clippy_lint.html"><strong aria-hidden="true">8.15.</strong> 定制静态分析 lint 检查规则</a></li><li class="chapter-item "><a href="../chapter_6/write-rust-lints-without-forking-clippy.html"><strong aria-hidden="true">8.16.</strong> 无需 fork Clippy 就可以编写 Rust lints</a></li><li class="chapter-item "><a href="../chapter_6/learn.html"><strong aria-hidden="true">8.17.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_6/proc_macro_workshop_guide_for_builder_project.html"><strong aria-hidden="true">8.18.</strong> Rust过程宏系列教程 | Proc Macro Workshop 之 Debug </a></li><li class="chapter-item "><a href="../chapter_6/rust_study_part_4.html"><strong aria-hidden="true">8.19.</strong> Rust 学习笔记系列｜ Part 4</a></li><li class="chapter-item "><a href="../chapter_6/rust_study_part_5.html"><strong aria-hidden="true">8.20.</strong> Rust 学习笔记系列｜ Part 5</a></li><li class="chapter-item "><a href="../chapter_6/rust_study_part_6.html"><strong aria-hidden="true">8.21.</strong> Rust 学习笔记系列｜ Part 6</a></li><li class="chapter-item "><a href="../chapter_6/rust_study_part_7.html"><strong aria-hidden="true">8.22.</strong> Rust 学习笔记系列｜ Part 7</a></li><li class="chapter-item "><a href="../chapter_6/parser-combinator.html"><strong aria-hidden="true">8.23.</strong> 用 Rust 学习解析器组合子 (combinator)</a></li><li class="chapter-item "><a href="../chapter_6/web3-part1.html"><strong aria-hidden="true">8.24.</strong> 对Web3.0概念的梳理</a></li><li class="chapter-item "><a href="../chapter_6/rabits.html"><strong aria-hidden="true">8.25.</strong> Rbatis ORM 2.0 | 零开销编译时动态SQL的探索</a></li><li class="chapter-item "><a href="../chapter_6/github_trending.html"><strong aria-hidden="true">8.26.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_6/tool_libs.html"><strong aria-hidden="true">8.27.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_6/frameworks.html"><strong aria-hidden="true">8.28.</strong> 推荐项目 |  框架引擎</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_7/toc.html"><strong aria-hidden="true">9.</strong> 七月刊（July）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_7/announce.html"><strong aria-hidden="true">9.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_7/lang.html"><strong aria-hidden="true">9.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_7/hots.html"><strong aria-hidden="true">9.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_7/events.html"><strong aria-hidden="true">9.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_7/jobs.html"><strong aria-hidden="true">9.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_7/rust_china_conf_2021.html"><strong aria-hidden="true">9.6.</strong> RustChinaConf 2021 议题征集开放申请</a></li><li class="chapter-item "><a href="../chapter_7/paper-rust-vs-c.html"><strong aria-hidden="true">9.7.</strong> 论文导读 | 性能与生产力 : Rust vs C </a></li><li class="chapter-item "><a href="../chapter_7/hw-rust-name-mangling.html"><strong aria-hidden="true">9.8.</strong> 华为 | Rust 调用约定和名称修饰规则介绍</a></li><li class="chapter-item "><a href="../chapter_7/ant-futures-compat.html"><strong aria-hidden="true">9.9.</strong> 蚂蚁集团 | Futures 0.1 和 0.3 兼容层的分析与应用</a></li><li class="chapter-item "><a href="../chapter_7/lark-rust-wasm-sqlite.html"><strong aria-hidden="true">9.10.</strong> 字节跳动 ｜ 飞书 Rust 实践 之 SQLite 适配 WASM </a></li><li class="chapter-item "><a href="../chapter_7/rust-epoll-rdma-part2.html"><strong aria-hidden="true">9.11.</strong> Datenlord | Rust实现RDMA异步编程（二）</a></li><li class="chapter-item "><a href="../chapter_7/how-we-improved-the-performance-of-our-rust-app.html"><strong aria-hidden="true">9.12.</strong> Zellij 的性能优化</a></li><li class="chapter-item "><a href="../chapter_7/learn.html"><strong aria-hidden="true">9.13.</strong> 学习资源</a></li><li class="chapter-item expanded "><a href="../chapter_7/rusts-standard-library-traits.html" class="active"><strong aria-hidden="true">9.14.</strong> 【完整】Rust 标准库 Trait 指南</a></li><li class="chapter-item "><a href="../chapter_7/coercion_in_rust.html"><strong aria-hidden="true">9.15.</strong> Rust 中的隐式类型转换</a></li><li class="chapter-item "><a href="../chapter_7/tokio-task-scheduler.html"><strong aria-hidden="true">9.16.</strong> Tokio Internals 之 任务调度</a></li><li class="chapter-item "><a href="../chapter_7/about-rust-features.html"><strong aria-hidden="true">9.17.</strong> 为什么你不应该沉迷于 Rust 的“特性”</a></li><li class="chapter-item "><a href="../chapter_7/rust-no-std.html"><strong aria-hidden="true">9.18.</strong> Rust no-std 工程实践</a></li><li class="chapter-item "><a href="../chapter_7/dynamic_analyzing_tools.html"><strong aria-hidden="true">9.19.</strong> Rust 内存错误调试和动态分析工具分享</a></li><li class="chapter-item "><a href="../chapter_7/macroquad_game.html"><strong aria-hidden="true">9.20.</strong> 使用Macroquad在Android设备上发布游戏</a></li><li class="chapter-item "><a href="../chapter_7/trampoline-kernel.html"><strong aria-hidden="true">9.21.</strong> 跨空间跳板内核</a></li><li class="chapter-item "><a href="../chapter_7/trait-upcasting-part1.html"><strong aria-hidden="true">9.22.</strong> Trait Upcasting 系列 ｜ Part I</a></li><li class="chapter-item "><a href="../chapter_7/github_trending.html"><strong aria-hidden="true">9.23.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_7/tool_libs.html"><strong aria-hidden="true">9.24.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_7/frameworks.html"><strong aria-hidden="true">9.25.</strong> 推荐项目 |  框架引擎</a></li></ol></li><li class="chapter-item "><a href="../chapter_8/toc.html"><strong aria-hidden="true">10.</strong> 八月刊（August）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_8/announce.html"><strong aria-hidden="true">10.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_8/lang.html"><strong aria-hidden="true">10.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_8/hots.html"><strong aria-hidden="true">10.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_8/events.html"><strong aria-hidden="true">10.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_8/jobs.html"><strong aria-hidden="true">10.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_8/rust_china_conf_2021.html"><strong aria-hidden="true">10.6.</strong> RustChinaConf 2021 正式启动</a></li><li class="chapter-item "><a href="../chapter_8/paper-rudra.html"><strong aria-hidden="true">10.7.</strong> 论文导读 | Rudra : 查找 Rust 生态系统中的内存安全 Bug </a></li><li class="chapter-item "><a href="../chapter_8/hw-rust-simd.html"><strong aria-hidden="true">10.8.</strong> 华为 | Rust语言中SIMD计算加速指令的使用</a></li><li class="chapter-item "><a href="../chapter_8/ant-futures-compat.html"><strong aria-hidden="true">10.9.</strong> 蚂蚁集团 | Trait Object 还是 Virtual Method Table</a></li><li class="chapter-item "><a href="../chapter_8/rust-lockfree-part2.html"><strong aria-hidden="true">10.10.</strong> Datenlord | Rust 无锁编程之Crossbeam Epoch算法解析</a></li><li class="chapter-item "><a href="../chapter_8/rust-k8s.html"><strong aria-hidden="true">10.11.</strong> DatenLord | Rust 实现K8S调度扩展</a></li><li class="chapter-item "><a href="../chapter_8/aws-lambda-rust-wasm-serverless.html"><strong aria-hidden="true">10.12.</strong> SecondState | AWS Lambda 中的 Rust 与 WebAssembly Serverless 函数</a></li><li class="chapter-item "><a href="../chapter_8/bianlifeng_embedded_rust.html"><strong aria-hidden="true">10.13.</strong> 便利蜂 | 门店网络与 Rust 落地实践</a></li><li class="chapter-item "><a href="../chapter_8/learn.html"><strong aria-hidden="true">10.14.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_8/rust-tips.html"><strong aria-hidden="true">10.15.</strong> Rust 技巧篇</a></li><li class="chapter-item "><a href="../chapter_8/reqwest-middleware.html"><strong aria-hidden="true">10.16.</strong> 为 reqwest 增加中间件支持</a></li><li class="chapter-item "><a href="../chapter_8/gui-framework-ingredients.html"><strong aria-hidden="true">10.17.</strong> 想用 Rust 编写 GUI 框架吗？</a></li><li class="chapter-item "><a href="../chapter_8/what-is-trait-upcasting.html"><strong aria-hidden="true">10.18.</strong> Trait Upcasting 系列 ｜ 如何把子 trait 转成父 trait ？</a></li><li class="chapter-item "><a href="../chapter_8/trait-upcasting-part2.html"><strong aria-hidden="true">10.19.</strong> Trait Upcasting 系列 ｜ Part II</a></li><li class="chapter-item "><a href="../chapter_8/github_trending.html"><strong aria-hidden="true">10.20.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_8/tool_libs.html"><strong aria-hidden="true">10.21.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_8/frameworks.html"><strong aria-hidden="true">10.22.</strong> 推荐项目 |  框架引擎</a></li></ol></li><li class="chapter-item "><a href="../chapter_9/toc.html"><strong aria-hidden="true">11.</strong> 九月刊（September）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_9/announce.html"><strong aria-hidden="true">11.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_9/lang.html"><strong aria-hidden="true">11.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_9/hots.html"><strong aria-hidden="true">11.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_9/events.html"><strong aria-hidden="true">11.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_9/jobs.html"><strong aria-hidden="true">11.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_9/rustconf.html"><strong aria-hidden="true">11.6.</strong> 官方 RustConf 2021 盘点</a></li><li class="chapter-item "><a href="../chapter_9/rust_china_conf_2021.html"><strong aria-hidden="true">11.7.</strong> RustChinaConf 2021 动态</a></li><li class="chapter-item "><a href="../chapter_9/foreign_journal_review.html"><strong aria-hidden="true">11.8.</strong> 将 TensorFlow 模型移植到 Pure Rust 的开发成本有多高？</a></li><li class="chapter-item "><a href="../chapter_9/foreign_journal_review.html"><strong aria-hidden="true">11.9.</strong> Rust 2021 有哪些新功能</a></li><li class="chapter-item "><a href="../chapter_9/foreign_journal_review.html"><strong aria-hidden="true">11.10.</strong> 周期性服务发现</a></li><li class="chapter-item "><a href="../chapter_9/rethink-async.html"><strong aria-hidden="true">11.11.</strong> Datenlord | 重新思考 Rust Async - 如何实现高性能 I/O</a></li><li class="chapter-item "><a href="../chapter_9/intel_sgx_std.html"><strong aria-hidden="true">11.12.</strong> Phala Network | 在Intel SGX环境下实现Rust原生std支持</a></li><li class="chapter-item "><a href="../chapter_9/rust-android-ui.html"><strong aria-hidden="true">11.13.</strong> 如何用Rust做Android UI渲染</a></li><li class="chapter-item "><a href="../chapter_9/learn.html"><strong aria-hidden="true">11.14.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_9/lifetime-smart-ptr.html"><strong aria-hidden="true">11.15.</strong> Rust 生命周期与智能指针</a></li><li class="chapter-item "><a href="../chapter_9/rust-for-embedded-c.html"><strong aria-hidden="true">11.16.</strong> 为 嵌入式 C  程序员编写的 Rust 指南</a></li><li class="chapter-item "><a href="../chapter_9/visualize_crate_graph.html"><strong aria-hidden="true">11.17.</strong> 可视化项目成员包的调用关系</a></li><li class="chapter-item "><a href="../chapter_9/poem-openapi.html"><strong aria-hidden="true">11.18.</strong> 基于 Poem 的 OpenAPI 服务端框架</a></li><li class="chapter-item "><a href="../chapter_9/rust-cryptography-ecosystem.html"><strong aria-hidden="true">11.19.</strong> 密码协议算法与Rust生态</a></li><li class="chapter-item "><a href="../chapter_9/github_trending.html"><strong aria-hidden="true">11.20.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_9/tool_libs.html"><strong aria-hidden="true">11.21.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_9/frameworks.html"><strong aria-hidden="true">11.22.</strong> 推荐项目 |  框架引擎</a></li><li class="chapter-item "><a href="../chapter_9/rust-security-part3.html"><strong aria-hidden="true">11.23.</strong> Rust生态安全漏洞总结系列 | Part 3</a></li></ol></li><li class="chapter-item "><a href="../chapter_10/toc.html"><strong aria-hidden="true">12.</strong> 十月刊（October）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_10/announce.html"><strong aria-hidden="true">12.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_10/lang.html"><strong aria-hidden="true">12.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_10/hots.html"><strong aria-hidden="true">12.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_10/events.html"><strong aria-hidden="true">12.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_10/jobs.html"><strong aria-hidden="true">12.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_10/rust-foundation.html"><strong aria-hidden="true">12.6.</strong> 聚焦Rust基金会新成员 | 为什么要加入 Rust 基金会 </a></li><li class="chapter-item "><a href="../chapter_10/rust-gcc-two-way.html"><strong aria-hidden="true">12.7.</strong> 【Linux Plumbers 大会总结】Rust 和 GCC 整合的两种方式</a></li><li class="chapter-item "><a href="../chapter_10/p99conf.html"><strong aria-hidden="true">12.8.</strong> P99 Conf Talk 汇总 |  Rust 在高性能低延迟系统中的应用</a></li><li class="chapter-item "><a href="../chapter_10/rust-coding-guidelines.html"><strong aria-hidden="true">12.9.</strong> 《Rust 安全编码规范》 初稿发布</a></li><li class="chapter-item "><a href="../chapter_10/foreign_journal_review.html"><strong aria-hidden="true">12.10.</strong> 知名项目进展报告</a></li><li class="chapter-item "><a href="../chapter_10/async-trait.html"><strong aria-hidden="true">12.11.</strong> Rust Async trait 更新与多线程</a></li><li class="chapter-item "><a href="../chapter_10/rust-mem-safety.html"><strong aria-hidden="true">12.12.</strong> Rust调研与内存安全</a></li><li class="chapter-item "><a href="../chapter_10/mocks-and-tokio.html"><strong aria-hidden="true">12.13.</strong> 对外输出 Mocks 接口 和 Tokio 的高延展性服务器设计</a></li><li class="chapter-item "><a href="../chapter_10/rdma-memory-management-in-rust.html"><strong aria-hidden="true">12.14.</strong> Datenlord |在 Rust 中管理 RDMA 内存 </a></li><li class="chapter-item "><a href="../chapter_10/dapr.html"><strong aria-hidden="true">12.15.</strong> SecondState | Dapr的一个轻量安全可移植且高性能的Runtime</a></li><li class="chapter-item "><a href="../chapter_10/dropbox.html"><strong aria-hidden="true">12.16.</strong> Dropbox | 为什么我们要为 Capture 构建自定义 Rust 库</a></li><li class="chapter-item "><a href="../chapter_10/learn.html"><strong aria-hidden="true">12.17.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_10/rust-koans.html"><strong aria-hidden="true">12.18.</strong> 【趣文】Rust 公案 ｜ 新锈与大师的对话</a></li><li class="chapter-item "><a href="../chapter_10/solana-learn-part1.html"><strong aria-hidden="true">12.19.</strong> 【区块链】Solana 开发笔记 Part 1</a></li><li class="chapter-item "><a href="../chapter_10/bad-practice.html"><strong aria-hidden="true">12.20.</strong> Rust 中常见的新手错误和不良习惯</a></li><li class="chapter-item "><a href="../chapter_10/lisp-in-rust.html"><strong aria-hidden="true">12.21.</strong> 用 Rust 实现 Lisp 解释器</a></li><li class="chapter-item "><a href="../chapter_10/rustc_plugin_custom_lints.html"><strong aria-hidden="true">12.22.</strong> 基于编译器插件定制 clippy lint</a></li><li class="chapter-item "><a href="../chapter_10/seaorm.html"><strong aria-hidden="true">12.23.</strong> Rust 生态观察｜ SeaORM: 要做 Rust 版本的 ActiveRecord  </a></li><li class="chapter-item "><a href="../chapter_10/delicate.html"><strong aria-hidden="true">12.24.</strong> Delicate 为什么从 actix-web 迁移到 poem</a></li><li class="chapter-item "><a href="../chapter_10/github_trending.html"><strong aria-hidden="true">12.25.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_10/tool_libs.html"><strong aria-hidden="true">12.26.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_10/rust-security-part4.html"><strong aria-hidden="true">12.27.</strong> Rust生态安全漏洞总结系列 | Part 4</a></li></ol></li><li class="chapter-item "><a href="../chapter_11/toc.html"><strong aria-hidden="true">13.</strong> 十一月刊（November）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_11/announce.html"><strong aria-hidden="true">13.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_11/lang.html"><strong aria-hidden="true">13.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_11/hots.html"><strong aria-hidden="true">13.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_11/events.html"><strong aria-hidden="true">13.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_11/jobs.html"><strong aria-hidden="true">13.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_11/io-safety.html"><strong aria-hidden="true">13.6.</strong> RFC 导读 | 构建安全的 I/O </a></li><li class="chapter-item "><a href="../chapter_11/pl_ub.html"><strong aria-hidden="true">13.7.</strong> PL 观点 |  未定义行为也有好的一面</a></li><li class="chapter-item "><a href="../chapter_11/meta-blockchain.html"><strong aria-hidden="true">13.8.</strong> 区块链快讯</a></li><li class="chapter-item "><a href="../chapter_11/foreign_journal_review.html"><strong aria-hidden="true">13.9.</strong> 外刊评论</a></li><li class="chapter-item "><a href="../chapter_11/mirchecker.html"><strong aria-hidden="true">13.10.</strong> 【论文导读】Rust 程序 Bug 静态检测工具 MirChecker</a></li><li class="chapter-item "><a href="../chapter_11/no-std.html"><strong aria-hidden="true">13.11.</strong> 华为 | no std的可执行文件编写和运行</a></li><li class="chapter-item "><a href="../chapter_11/core-arch.html"><strong aria-hidden="true">13.12.</strong> 华为 | 硬件加速指令实践心得</a></li><li class="chapter-item "><a href="../chapter_11/rust-profiling.html"><strong aria-hidden="true">13.13.</strong> DatenLord | Rust程序性能分析</a></li><li class="chapter-item "><a href="../chapter_11/play-async.html"><strong aria-hidden="true">13.14.</strong> 蚂蚁集团 ｜ Play With Your Async Code</a></li><li class="chapter-item "><a href="../chapter_11/learn.html"><strong aria-hidden="true">13.15.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_11/symlink_metadata.html"><strong aria-hidden="true">13.16.</strong> Rust Tips : 软链接引发的卡死问题</a></li><li class="chapter-item "><a href="../chapter_11/rust-reading-club-part1.html"><strong aria-hidden="true">13.17.</strong> Rust 源码阅读俱乐部 |  第一期 : 名称解析</a></li><li class="chapter-item "><a href="../chapter_11/rust-memory-model.html"><strong aria-hidden="true">13.18.</strong> 【我读】Rust 语言应该使用什么内存模型？</a></li><li class="chapter-item "><a href="../chapter_11/bench-and-const.html"><strong aria-hidden="true">13.19.</strong> Rust AEAD benchmark 与 Const generics</a></li><li class="chapter-item "><a href="../chapter_11/signal.html"><strong aria-hidden="true">13.20.</strong> Rust与Linux信号</a></li><li class="chapter-item "><a href="../chapter_11/github_trending.html"><strong aria-hidden="true">13.21.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_11/tool_libs.html"><strong aria-hidden="true">13.22.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_11/security-log.html"><strong aria-hidden="true">13.23.</strong> 每月安全公告</a></li><li class="chapter-item "><a href="../chapter_11/trojan-source.html"><strong aria-hidden="true">13.24.</strong> 特洛伊之源｜ 在 Rust 代码中隐藏无形的漏洞</a></li><li class="chapter-item "><a href="../chapter_11/crates-backdoor.html"><strong aria-hidden="true">13.25.</strong> Rust Crates可能的后门与Cargo</a></li></ol></li><li class="chapter-item "><a href="../chapter_12/toc.html"><strong aria-hidden="true">14.</strong> 十二月刊（December）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../chapter_12/announce.html"><strong aria-hidden="true">14.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="../chapter_12/lang.html"><strong aria-hidden="true">14.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="../chapter_12/hots.html"><strong aria-hidden="true">14.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="../chapter_12/events.html"><strong aria-hidden="true">14.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="../chapter_12/jobs.html"><strong aria-hidden="true">14.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="../chapter_12/rust-mod-team-follow-up.html"><strong aria-hidden="true">14.6.</strong> 【官方】对 Rust 审核团队问题的后续跟进</a></li><li class="chapter-item "><a href="../chapter_12/meta-blockchain.html"><strong aria-hidden="true">14.7.</strong> 区块链快讯</a></li><li class="chapter-item "><a href="../chapter_12/foreign_journal_review.html"><strong aria-hidden="true">14.8.</strong> 外刊评论</a></li><li class="chapter-item "><a href="../chapter_12/static-async-fn.html"><strong aria-hidden="true">14.9.</strong> Rust RFC static async fn in trait</a></li><li class="chapter-item "><a href="../chapter_12/serde.html"><strong aria-hidden="true">14.10.</strong> Rust 裸函数相关新RFC 和 序列化</a></li><li class="chapter-item "><a href="../chapter_12/ref.html"><strong aria-hidden="true">14.11.</strong> Rust for Linux 源码导读 | Ref 引用计数容器</a></li><li class="chapter-item "><a href="../chapter_12/ant-go-with-rust.html"><strong aria-hidden="true">14.12.</strong> 蚂蚁集团 | 一次 Go 中嵌入 Rust 库的踩坑实践</a></li><li class="chapter-item "><a href="../chapter_12/monoio.html"><strong aria-hidden="true">14.13.</strong> 字节跳动 | Rust 异步运行时的设计与实现</a></li><li class="chapter-item "><a href="../chapter_12/tokio_part1.html"><strong aria-hidden="true">14.14.</strong> 达坦科技 | tokio 解析之任务调度</a></li><li class="chapter-item "><a href="../chapter_12/lock-free-implementation.html"><strong aria-hidden="true">14.15.</strong> 飞蓬网络 | 特定场景下的Rust无锁队列实现</a></li><li class="chapter-item "><a href="../chapter_12/signal.html"><strong aria-hidden="true">14.16.</strong> Signal | 如何用Rust构建大规模端到端加密通话</a></li><li class="chapter-item "><a href="../chapter_12/learn.html"><strong aria-hidden="true">14.17.</strong> 学习资源</a></li><li class="chapter-item "><a href="../chapter_12/simple-rust-in-assembly.html"><strong aria-hidden="true">14.18.</strong> Rust基础语句汇编分析</a></li><li class="chapter-item "><a href="../chapter_12/rust_for_rustaceans_reading_notes_ch13.html"><strong aria-hidden="true">14.19.</strong> 《Rust For Rustaceans》读书笔记之Rust生态系统</a></li><li class="chapter-item "><a href="../chapter_12/lock-free.html"><strong aria-hidden="true">14.20.</strong> 代码杂谈：无锁编程</a></li><li class="chapter-item "><a href="../chapter_12/rust-pin-advanced.html"><strong aria-hidden="true">14.21.</strong> Rust Pin 进阶</a></li><li class="chapter-item "><a href="../chapter_12/rust-perf.html"><strong aria-hidden="true">14.22.</strong> Rust性能评估与调优实践</a></li><li class="chapter-item "><a href="../chapter_12/async_cancel_propagation.html"><strong aria-hidden="true">14.23.</strong> Tokio 异步传播的缺陷</a></li><li class="chapter-item "><a href="../chapter_12/lets-make-os.html"><strong aria-hidden="true">14.24.</strong> 来造一个OS吧</a></li><li class="chapter-item "><a href="../chapter_12/llvm-infrastructure-and-rust.html"><strong aria-hidden="true">14.25.</strong> LLVM基础设施和Rust</a></li><li class="chapter-item "><a href="../chapter_12/github_trending.html"><strong aria-hidden="true">14.26.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="../chapter_12/tool_libs.html"><strong aria-hidden="true">14.27.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="../chapter_12/security-log.html"><strong aria-hidden="true">14.28.</strong> 每月安全公告</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust精选</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/RustMagazine/rust_magazine_2021" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#完整rust-标准库-trait-指南" id="完整rust-标准库-trait-指南">【完整】Rust 标准库 Trait 指南</a></h1>
<p>译者： Praying</p>
<blockquote>
<ul>
<li>原文标题：Tour of Rust's Standard Library Traits</li>
<li>原文链接：<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md </a></li>
<li>说明： 可能网络中也存在其他翻译，但本篇是由 Praying 独立翻译完成的。</li>
</ul>
</blockquote>
<h2><a class="header" href="#内容目录" id="内容目录">内容目录</a></h2>
<ul>
<li>引言 </li>
<li>Trait 基础 </li>
<li>自动 Trait</li>
<li>泛型 Trait</li>
<li>格式化 Trait</li>
<li>操作符 Trait</li>
<li>转换 Trait</li>
<li>错误处理 </li>
<li>迭代器 Trait</li>
<li>I/O Trait</li>
<li>总结 </li>
</ul>
<h2><a class="header" href="#引言" id="引言">引言</a></h2>
<p>你是否曾想过下面这些 trait 有什么不同？</p>
<ul>
<li><code>Deref&lt;Traget=T&gt;</code>，<code>AsRef&lt;T&gt;</code>，以及<code>Borrow&lt;T&gt;</code>？</li>
<li><code>Clone</code>，<code>Copy</code>，和<code>ToOwned</code>？</li>
<li><code>From&lt;T&gt;</code> 和<code>Into&lt;T&gt;</code>?</li>
<li><code>TryFrom&lt;&amp;str&gt;</code> 和<code>FromStr</code>？</li>
<li><code>FnOnce</code>，<code>FnMut</code>，<code>Fn</code>和<code>fn</code>?</li>
</ul>
<p>或者你曾问过自己下面这些问题：</p>
<ul>
<li>
<p>“我在 trait 中，什么时候使用关联类型（associated type），什么时候使用泛型（generic types）？”</p>
</li>
<li>
<p>“什么是泛型覆盖实现（generic <a href="https://doc.rust-lang.org/book/ch10-02-traits.html?highlight=blanket#using-trait-bounds-to-conditionally-implement-methods" title="blanket impls">blanket impls</a>）”?</p>
</li>
<li>
<p>“subtrait 和 supertrait 是如何工作的？”</p>
</li>
<li>
<p>“为什么这个 trait 没有任何方法？”</p>
</li>
</ul>
<p>那么这篇文章就是为你而写的！它回答了包括但不限于上述所有的问题。我们将一起对 Rust 标准库中所有最流行和最常用的 trait 进行快速的浏览。<br/></p>
<p>你可以按章节顺序阅读本文，也可以跳到你最感兴趣的 trait，因为每个 trait 章节的开头都有一个指向前置章节的链接列表，你应该阅读这些链接，以便有足够的背景知识来理解当前章节的解释（译注：很抱歉，译文中暂时无法提供链接跳转）。</p>
<h2><a class="header" href="#trait-基础" id="trait-基础">Trait 基础</a></h2>
<p>我们将会覆盖足够多的基础知识，这样文章的其余部分就可以精简，而不必因为它们在不同的 trait 中反复出现而重复解释相同的概念。</p>
<h3><a class="header" href="#trait-项item" id="trait-项item">Trait 项（Item）</a></h3>
<p>Trait 项是指包含于 trait 声明中的任意项。</p>
<h4><a class="header" href="#self" id="self">Self</a></h4>
<p><code>Self</code>总是指代实现类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    // always returns i32
    fn returns_num() -&gt; i32;

    // returns implementing type
    fn returns_self() -&gt; Self;
}

struct SomeType;
struct OtherType;

impl Trait for SomeType {
    fn returns_num() -&gt; i32 {
        5
    }

    // Self == SomeType
    fn returns_self() -&gt; Self {
        SomeType
    }
}

impl Trait for OtherType {
    fn returns_num() -&gt; i32 {
        6
    }

    // Self == OtherType
    fn returns_self() -&gt; Self {
        OtherType
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#函数function" id="函数function">函数（Function）</a></h4>
<p>Trait 函数是指第一个参数不是<code>self</code>关键字的任意函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Default {
    // function
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 函数可以通过 trait 或者实现类型的命名空间来调用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let zero: i32 = Default::default();
    let zero = i32::default();
}
</code></pre></pre>
<h4><a class="header" href="#方法method" id="方法method">方法（Method）</a></h4>
<p>Trait 方法是指，第一个参数使用了<code>self</code>关键字并且<code>self</code>的类型是<code>Self</code>,<code>&amp;Self</code>，<code>&amp;mut Self</code>之一。<code>self</code>的类型也可以被<code>Box</code>，<code>Rc</code>，<code>Arc</code>或<code>Pin</code>来包装。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    // methods
    fn takes_self(self);
    fn takes_immut_self(&amp;self);
    fn takes_mut_self(&amp;mut self);

    // above methods desugared
    fn takes_self(self: Self);
    fn takes_immut_self(self: &amp;Self);
    fn takes_mut_self(self: &amp;mut Self);
}

// example from standard library
trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 方法可以通过在实现类型上使用点（.）操作符来调用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let five = 5.to_string();
}
</code></pre></pre>
<p>此外，trait 方法还可以像函数那样由 trait 或者实现类型通过命名空间来调用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let five = ToString::to_string(&amp;5);
    let five = i32::to_string(&amp;5);
}
</code></pre></pre>
<h4><a class="header" href="#关联类型associated-types" id="关联类型associated-types">关联类型（Associated Types）</a></h4>
<p>Trait 可以有关联类型。当我们需要在函数签名中使用<code>Self</code>以外的某个类型，但是希望这个类型可以由实现者来选择而不是硬编码到 trait 声明中，这时关联类型就可以发挥作用了。</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    type AssociatedType;
    fn func(arg: Self::AssociatedType);
}

struct SomeType;
struct OtherType;

// any type implementing Trait can
// choose the type of AssociatedType

impl Trait for SomeType {
    type AssociatedType = i8; // chooses i8
    fn func(arg: Self::AssociatedType) {}
}

impl Trait for OtherType {
    type AssociatedType = u8; // chooses u8
    fn func(arg: Self::AssociatedType) {}
}

fn main() {
    SomeType::func(-1_i8); // can only call func with i8 on SomeType
    OtherType::func(1_u8); // can only call func with u8 on OtherType
}
</code></pre></pre>
<h4><a class="header" href="#泛型参数generic-parameters" id="泛型参数generic-parameters">泛型参数（Generic Parameters）</a></h4>
<p>“泛型参数”泛指泛型类型参数（generic type parameters）、泛型生命周期参数（generic lifetime parameters）、以及泛型常量参数（generic const parameters）。因为这些说起来比较拗口，所以人们通常把它们简称为 “泛型类型（generic type）”、“生命周期（lifetime）”和 “泛型常量（generic const）”。由于我们将要讨论的所有标准库 trait 中都没有使用泛型常量，所以它们不在本文的讨论范围之内。</p>
<p>我们可以使用参数来对一个 trait 声明进行泛化（generalize ）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// trait declaration generalized with lifetime &amp; type parameters
trait Trait&lt;'a, T&gt; {
    // signature uses generic type
    fn func1(arg: T);

    // signature uses lifetime
    fn func2(arg: &amp;'a i32);

    // signature uses generic type &amp; lifetime
    fn func3(arg: &amp;'a T);
}

struct SomeType;

impl&lt;'a&gt; Trait&lt;'a, i8&gt; for SomeType {
    fn func1(arg: i8) {}
    fn func2(arg: &amp;'a i32) {}
    fn func3(arg: &amp;'a i8) {}
}

impl&lt;'b&gt; Trait&lt;'b, u8&gt; for SomeType {
    fn func1(arg: u8) {}
    fn func2(arg: &amp;'b i32) {}
    fn func3(arg: &amp;'b u8) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>泛型可以具有默认值，最常用的默认值是<code>Self</code>，但是任何类型都可以作为默认值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// make T = Self by default
trait Trait&lt;T = Self&gt; {
    fn func(t: T) {}
}

// any type can be used as the default
trait Trait2&lt;T = i32&gt; {
    fn func2(t: T) {}
}

struct SomeType;

// omitting the generic type will
// cause the impl to use the default
// value, which is Self here
impl Trait for SomeType {
    fn func(t: SomeType) {}
}

// default value here is i32
impl Trait2 for SomeType {
    fn func2(t: i32) {}
}

// the default is overridable as we'd expect
impl Trait&lt;String&gt; for SomeType {
    fn func(t: String) {}
}

// overridable here too
impl Trait2&lt;String&gt; for SomeType {
    fn func2(t: String) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>除了可以对 trait 进行参数化之外，我们还可以对单个函数和方法进行参数化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn func&lt;'a, T&gt;(t: &amp;'a T);
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#泛型类型-vs-关联类型" id="泛型类型-vs-关联类型">泛型类型 vs 关联类型</a></h4>
<p>泛型类型和关联类型都把在 trait 的函数和方法中使用哪种具体类型的决定权交给了实现者，因此这部分内容要去解释什么时候使用泛型类型，什么时候使用关联类型。</p>
<p>通常的经验法则是：</p>
<ul>
<li>
<p>当每个类型只应该有 trait 的一个实现时，使用关联类型。</p>
</li>
<li>
<p>当每个类型可能会有 trait 的多个实现时，使用泛型类型。</p>
</li>
</ul>
<p>比如说我们想要定义一个名为<code>Add</code>的 trait，该 trait 允许我们对值进行相加。下面是一个最初的设计和实现，里面只使用了关联类型。</p>
<pre><pre class="playground"><code class="language-rust">trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>假设现在我们想要添加这样一种功能：把<code>i32</code>加到<code>Point</code>上，其中<code>Point</code>里面的成员<code>x</code>和<code>y</code>都会加上<code>i32</code>。</p>
<pre><pre class="playground"><code class="language-rust">trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add for Point { // ❌
    type Rhs = i32;
    type Output = Point;
    fn add(self, rhs: i32) -&gt; Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2); // ❌
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>上面的代码会抛出错误：</p>
<pre><code>error[E0119]: conflicting implementations of trait `Add` for type `Point`:
  --&gt; src/main.rs:23:1
   |
12 | impl Add for Point {
   | ------------------ first implementation here
...
23 | impl Add for Point {
   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`
</code></pre>
<p>因为<code>Add</code> trait 没有被任何的泛型类型参数化，我们只能在每个类型上实现这个 trait 一次，这意味着，我们只能一次把<code>Rhs</code>和<code>Output</code>类型都选取好！为了能够使<code>Point</code>和<code>i32</code>类型都能和<code>Point</code>相加，我们必须把<code>Rhs</code>从一个关联类型重构为泛型类型，这样就能够让我们根据<code>Rhs</code>不同的类型参数来为<code>Point</code>实现 trait 多次。</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;Rhs&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add&lt;Point&gt; for Point {
    type Output = Self;
    fn add(self, rhs: Point) -&gt; Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add&lt;i32&gt; for Point { // ✅
    type Output = Self;
    fn add(self, rhs: i32) -&gt; Self::Output {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2); // ✅
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>假如说我们增加了一个名为<code>Line</code>的新类型，它包含两个<code>Point</code>，现在，在我们的程序中存在这样一种上下文环境，即将两个<code>Point</code>相加之后应该产生一个<code>Line</code>而不是另一个<code>Point</code>。这在当我们当前的<code>Add</code> trait 设计中是不可行的，因为<code>Output</code>是一个关联类型，但是我们通过把<code>Output</code>从关联类型重构为泛型类型来实现这个新需求。</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;Rhs, Output&gt; {
    fn add(self, rhs: Rhs) -&gt; Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add&lt;Point, Point&gt; for Point {
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add&lt;i32, Point&gt; for Point {
    fn add(self, rhs: i32) -&gt; Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

struct Line {
    start: Point,
    end: Point,
}

impl Add&lt;Point, Line&gt; for Point { // ✅
    fn add(self, rhs: Point) -&gt; Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3: Point = p1.add(p2);
    assert!(p3.x == 3 &amp;&amp; p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert!(p3.x == 3 &amp;&amp; p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let l: Line = p1.add(p2); // ✅
    assert!(l.start.x == 1 &amp;&amp; l.start.y == 1 &amp;&amp; l.end.x == 2 &amp;&amp; l.end.y == 2)
}
</code></pre></pre>
<p>所以，哪个<code>Add</code> trait 是最好的呢？这取决于你程序中的需求！放在合适的场景中，它们都很好。</p>
<h3><a class="header" href="#作用域scope" id="作用域scope">作用域（Scope）</a></h3>
<p>只有当 trait 在作用域之中时，trait 项才能被使用。大多数 Rustaceans 在第一次尝试写一个 I/O 相关的程序时，都会在吃过一番苦头之后了解到这一点，因为<code>Read</code>和<code>Write</code>的 trait 并不在标准库的预置（prelude）中。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = File::open(&quot;Cargo.toml&quot;)?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?; // ❌ read_to_string not found in File
    Ok(())
}
</code></pre></pre>
<p><code>read_to_string(buf: &amp;mut String)</code>声明于<code>std::io::Read</code>中并且被<code>std::fs::File</code>结构体实现，但是要想调用它，<code>std::io::Read</code>必须在当前作用域中。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;
use std::io::Read; // ✅

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = File::open(&quot;Cargo.toml&quot;)?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?; // ✅
    Ok(())
}
</code></pre></pre>
<p>标准库预置（The standard library prelude）是标准库中的一个模块，也就是说，<code>std::prelude::v1</code>，它在每个其他模块的顶部被自动导入，即<code>use std::prelude::v1::*</code>。这样的话，下面这些 trait 就总会在作用域中，我们不需要自己显式地导入它们，因为它们是预置的一部分。</p>
<ul>
<li>AsMut</li>
<li>AsRef</li>
<li>Clone</li>
<li>Copy</li>
<li>Default</li>
<li>Drop</li>
<li>Eq</li>
<li>Fn</li>
<li>FnMut</li>
<li>FnOnce</li>
<li>From</li>
<li>Into</li>
<li>ToOwned</li>
<li>IntoIterator</li>
<li>Iterator</li>
<li>PartialEq</li>
<li>PartialOrd</li>
<li>Send</li>
<li>Sized</li>
<li>Sync</li>
<li>ToString</li>
<li>Ord</li>
</ul>
<h3><a class="header" href="#派生宏derive-macros" id="派生宏derive-macros">派生宏（Derive Macros）</a></h3>
<p>标准库导出了一小部分派生宏，这么派生宏可以让我们可以便捷地在一个类型上实现 trait，前提是该类型的所有成员都实现了这个 trait。派生宏以它们所实现的 trait 来命名。</p>
<ul>
<li>Clone</li>
<li>Copy</li>
<li>Debug</li>
<li>Default</li>
<li>Eq</li>
<li>Hash</li>
<li>Ord</li>
<li>PartialEq</li>
<li>PartialOrd</li>
</ul>
<p>使用示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// macro derives Copy &amp; Clone impl for SomeType
#[derive(Copy, Clone)]
struct SomeType;
<span class="boring">}
</span></code></pre></pre>
<p>注意：派生宏也是过程宏（procedural macros），它们可以被用来做任何事情，没有强制规定它们必须要实现一个 trait，或者它们只能在所有成员都实现 trait 的情况下才能工作，这些只是标准库中派生宏所遵循的惯例。</p>
<h3><a class="header" href="#默认实现default-impls" id="默认实现default-impls">默认实现（Default Impls）</a></h3>
<p>Trait 可以为它们的函数和方法提供默认实现。</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(&amp;self) {
        println!(&quot;default impl&quot;);
    }
}

struct SomeType;
struct OtherType;

// use default impl for Trait::method
impl Trait for SomeType {}

impl Trait for OtherType {
    // use our own impl for Trait::method
    fn method(&amp;self) {
        println!(&quot;OtherType impl&quot;);
    }
}

fn main() {
    SomeType.method(); // prints &quot;default impl&quot;
    OtherType.method(); // prints &quot;OtherType impl&quot;
}
</code></pre></pre>
<p>如果 trait 中的某些方法是完全通过 trait 的另一些方法来实现的，这就非常方便了。</p>
<pre><pre class="playground"><code class="language-rust">trait Greet {
    fn greet(&amp;self, name: &amp;str) -&gt; String;
    fn greet_loudly(&amp;self, name: &amp;str) -&gt; String {
        self.greet(name) + &quot;!&quot;
    }
}

struct Hello;
struct Hola;

impl Greet for Hello {
    fn greet(&amp;self, name: &amp;str) -&gt; String {
        format!(&quot;Hello {}&quot;, name)
    }
    // use default impl for greet_loudly
}

impl Greet for Hola {
    fn greet(&amp;self, name: &amp;str) -&gt; String {
        format!(&quot;Hola {}&quot;, name)
    }
    // override default impl
    fn greet_loudly(&amp;self, name: &amp;str) -&gt; String {
        let mut greeting = self.greet(name);
        greeting.insert_str(0, &quot;¡&quot;);
        greeting + &quot;!&quot;
    }
}

fn main() {
    println!(&quot;{}&quot;, Hello.greet(&quot;John&quot;)); // prints &quot;Hello John&quot;
    println!(&quot;{}&quot;, Hello.greet_loudly(&quot;John&quot;)); // prints &quot;Hello John!&quot;
    println!(&quot;{}&quot;, Hola.greet(&quot;John&quot;)); // prints &quot;Hola John&quot;
    println!(&quot;{}&quot;, Hola.greet_loudly(&quot;John&quot;)); // prints &quot;¡Hola John!&quot;
}
</code></pre></pre>
<p>标准库中的很多 trait 为很多它们的方法提供了默认实现。</p>
<h3><a class="header" href="#泛型覆盖实现generic-blanket-impls" id="泛型覆盖实现generic-blanket-impls">泛型覆盖实现（Generic Blanket Impls）</a></h3>
<p>泛型覆盖实现是一种在泛型类型而不是具体类型上的实现，为了解释为什么以及如何使用它，让我们从为整数类型实现一个<code>is_even</code>方法开始。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Even {
    fn is_even(self) -&gt; bool;
}

impl Even for i8 {
    fn is_even(self) -&gt; bool {
        self % 2_i8 == 0_i8
    }
}

impl Even for u8 {
    fn is_even(self) -&gt; bool {
        self % 2_u8 == 0_u8
    }
}

impl Even for i16 {
    fn is_even(self) -&gt; bool {
        self % 2_i16 == 0_i16
    }
}

// etc

#[test] // ✅
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
<span class="boring">}
</span></code></pre></pre>
<p>很明显，上面的实现十分啰嗦。而且，所有我们的实现几乎都是一样的。此外，如果 Rust 决定在未来增加更多的整数类型，我们必须回到这段代码中，用新的整数类型来更新它。我们可以通过使用泛型覆盖实现来解决所有的问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -&gt; bool;
}

// generic blanket impl
impl&lt;T&gt; Even for T
where
    T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
    u8: TryInto&lt;T&gt;,
    &lt;u8 as TryInto&lt;T&gt;&gt;::Error: Debug,
{
    fn is_even(self) -&gt; bool {
        // these unwraps will never panic
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

#[test] // ✅
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
<span class="boring">}
</span></code></pre></pre>
<p>不同于默认实现，泛型覆盖实现提供了方法的实现，所以它们不能被重写。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -&gt; bool;
}

impl&lt;T&gt; Even for T
where
    T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
    u8: TryInto&lt;T&gt;,
    &lt;u8 as TryInto&lt;T&gt;&gt;::Error: Debug,
{
    fn is_even(self) -&gt; bool {
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

impl Even for u8 { // ❌
    fn is_even(self) -&gt; bool {
        self % 2_u8 == 0_u8
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码会抛出下面的错误：</p>
<pre><code>error[E0119]: conflicting implementations of trait `Even` for type `u8`:
  --&gt; src/lib.rs:22:1
   |
10 | / impl&lt;T&gt; Even for T
11 | | where
12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
13 | |     u8: TryInto&lt;T&gt;,
...  |
19 | |     }
20 | | }
   | |_- first implementation here
21 |
22 |   impl Even for u8 {
   |   ^^^^^^^^^^^^^^^^ conflicting implementation for `u8`
</code></pre>
<p>这些实现有重叠，因此它们是冲突的，所以 Rust 拒绝编译这段代码以确保 trait 的一致性。trait 一致性是指，对于任意给定的类型，最多存在某一 trait 的一个实现。Rust 用来强制执行特质一致性的规则，这些规则的含义，以及针对这些含义的变通方案都不在本文的讨论范围之内。</p>
<h3><a class="header" href="#subtraits--supertraits" id="subtraits--supertraits">Subtraits &amp; Supertraits</a></h3>
<p><code>subtrait</code>中的<code>sub</code>指的是子集（subset)，<code>supertrait</code>中的<code>super</code>指的是超集（superset）。如果我们有下面这个 trait 声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Subtrait: Supertrait {}
<span class="boring">}
</span></code></pre></pre>
<p>所有实现了<code>Subtrait</code>的类型是所有实现了<code>Supertrait</code>的类型的子集，或者反过来讲：所有实现了<code>Supertrait</code>的类型是所有实现了<code>Subtrait</code>类型的子集。而且，上面的代码是一种语法糖，展开来应该是：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Subtrait where Self: Supertrait {}
<span class="boring">}
</span></code></pre></pre>
<p>这是一个微妙而重要的区别，要明白约束在<code>Self</code>上，也就是实现<code>Subtrait</code>的类型而非<code>Subtrait</code>自身。后者也没有意义，因为 trait 约束只能作用于能够实现 trait 的具体类型，trait 本身不能实现其他的 trait：</p>
<pre><pre class="playground"><code class="language-rust">trait Supertrait {
    fn method(&amp;self) {
        println!(&quot;in supertrait&quot;);
    }
}

trait Subtrait: Supertrait {
    // this looks like it might impl or
    // override Supertrait::method but it
    // does not
    fn method(&amp;self) {
        println!(&quot;in subtrait&quot;)
    }
}

struct SomeType;

// adds Supertrait::method to SomeType
impl Supertrait for SomeType {}

// adds Subtrait::method to SomeType
impl Subtrait for SomeType {}

// both methods exist on SomeType simultaneously
// neither overriding or shadowing the other

fn main() {
    SomeType.method(); // ❌ ambiguous method call
    // must disambiguate using fully-qualified syntax
    &lt;SomeType as Supertrait&gt;::method(&amp;st); // ✅ prints &quot;in supertrait&quot;
    &lt;SomeType as Subtrait&gt;::method(&amp;st); // ✅ prints &quot;in subtrait&quot;
}
</code></pre></pre>
<p>此外，对于一个类型如何同时实现一个 subtrait 和一个 supertrait，也没有明确的规则。它可以在另一个类型的实现中实现其他的方法。</p>
<pre><pre class="playground"><code class="language-rust">trait Supertrait {
    fn super_method(&amp;mut self);
}

trait Subtrait: Supertrait {
    fn sub_method(&amp;mut self);
}

struct CallSuperFromSub;

impl Supertrait for CallSuperFromSub {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
    }
}

impl Subtrait for CallSuperFromSub {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
        self.super_method();
    }
}

struct CallSubFromSuper;

impl Supertrait for CallSubFromSuper {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
        self.sub_method();
    }
}

impl Subtrait for CallSubFromSuper {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
    }
}

struct CallEachOther(bool);

impl Supertrait for CallEachOther {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
        if self.0 {
            self.0 = false;
            self.sub_method();
        }
    }
}

impl Subtrait for CallEachOther {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
        if self.0 {
            self.0 = false;
            self.super_method();
        }
    }
}

fn main() {
    CallSuperFromSub.super_method(); // prints &quot;in super&quot;
    CallSuperFromSub.sub_method(); // prints &quot;in sub&quot;, &quot;in super&quot;

    CallSubFromSuper.super_method(); // prints &quot;in super&quot;, &quot;in sub&quot;
    CallSubFromSuper.sub_method(); // prints &quot;in sub&quot;

    CallEachOther(true).super_method(); // prints &quot;in super&quot;, &quot;in sub&quot;
    CallEachOther(true).sub_method(); // prints &quot;in sub&quot;, &quot;in super&quot;
}
</code></pre></pre>
<p>希望上面的例子能够表达出，subtrait 和 supertrait 之间可以是很复杂的关系。在介绍能够将这些复杂性进行整洁封装的心智模型之前，让我们快速回顾并建立我们用来理解泛型类型上的 trait 约束的心智模型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T: Clone&gt;(t: T) {
    // impl
}
<span class="boring">}
</span></code></pre></pre>
<p>在不知道这个函数的实现的情况下，我们可以合理地猜测，<code>t.clone()</code>会在某个时候被调用，因为当一个泛型类型被一个 trait 所约束时，意味着它对 trait 有依赖性。泛型与 trait 约束之间关系的心智模型是一个简单而直观的模型：泛型依赖于 trait 约束。</p>
<p>现在让我们看看<code>Copy</code>的 trait 声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy: Clone {}
<span class="boring">}
</span></code></pre></pre>
<p>上面的语法看起来与在一个泛型类型上应用 trait 约束很相似，但是<code>Copy</code>完全不依赖于<code>Clone</code>。之前的模型在这里没有帮助。个人认为，理解 subtrait 和 supertrait 最为简洁优雅的心智模型是：subtrait 细化（refine）了它们的 supertrait。</p>
<p>“细化（Refinement）”刻意保持一定的模糊性，因为它们在不同的上下文环境中会有不同的含义：</p>
<ul>
<li>
<p>subtrait 可能会使得 supertrait 的方法实现更为具体，快速，占用更少的内存，例如，<code>Copy:Clone</code>；</p>
</li>
<li>
<p>subtrait 可能会对 supertrait 的方法实现增加额外的保证，例如：<code>Eq: PartialEq</code>,<code>Ord: PartialOrd</code>,<code>ExactSizeIterator: Iterator</code>;</p>
</li>
<li>
<p>subtrait 可能会使得 supertrait 的方法更为灵活和易于调用，例如：<code>FnMut: FnOnce</code>,<code>Fn: FnMut</code>;</p>
</li>
<li>
<p>subtrait 可能会扩展 supertrait 并添加新的方法，例如：<code>DoubleEndedIterator: Iterator</code>,<code>ExactSizeIterator: Iterator</code>。</p>
</li>
</ul>
<h3><a class="header" href="#trait-对象" id="trait-对象">Trait 对象</a></h3>
<p>泛型给我们提供了编译期多态，而 trait 对象给我们提供了运行时多态。我们可以使用 trait 对象来让函数在运行时动态地返回不同的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(condition: bool, vec: Vec&lt;i32&gt;) -&gt; Box&lt;dyn Iterator&lt;Item = i32&gt;&gt; {
    let iter = vec.into_iter();
    if condition {
        // Has type:
        // Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
        // But is cast to:
        // Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
        Box::new(iter.map(|n| n * 2))
    } else {
        // Has type:
        // Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
        // But is cast to:
        // Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
        Box::new(iter.filter(|&amp;n| n &gt;= 2))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 对象还允许我们在集合中存储多种类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f64::consts::PI;

struct Circle {
    radius: f64,
}

struct Square {
    side: f64
}

trait Shape {
    fn area(&amp;self) -&gt; f64;
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f64 {
        PI * self.radius * self.radius
    }
}

impl Shape for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn get_total_area(shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt;) -&gt; f64 {
    shapes.into_iter().map(|s| s.area()).sum()
}

fn example() {
    let shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt; = vec![
        Box::new(Circle { radius: 1.0 }), // Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
        Box::new(Square { side: 1.0 }), // Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
    ];
    assert_eq!(PI + 1.0, get_total_area(shapes)); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 对象是没有大小的，所以它们必须总是在一个指针后面。我们可以根据类型中<code>dyn</code>关键字的存在来区分具体类型和 trait 对象在类型级别上的区别。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;
trait Trait {}

// regular struct
&amp;Struct
Box&lt;Struct&gt;
Rc&lt;Struct&gt;
Arc&lt;Struct&gt;

// trait objects
&amp;dyn Trait
Box&lt;dyn Trait&gt;
Rc&lt;dyn Trait&gt;
Arc&lt;dyn Trait&gt;
<span class="boring">}
</span></code></pre></pre>
<p>不是所有的 trait 都可以被转成 trait 对象。当且仅当一个 trait 满足下面这些要求时，它才是对象安全的（object-safe）：</p>
<ul>
<li>trait 不要求<code>Self:Sized</code></li>
<li>trait 的所有方法都是对象安全的</li>
</ul>
<p>当一个 trait 方法满足下面的要求时，该方法是对象安全的：</p>
<ul>
<li>方法要求<code>Self:Sized</code> 或者</li>
<li>方法在其接收者位置仅使用一个<code>Self</code>类型</li>
</ul>
<p>理解为什么要求是这样的，与本文的其余部分无关，但如果你仍然好奇，可以阅读<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md" title="Sizeness in Rust">Sizeness in Rust</a>（译注：Sizedness in Rust 这篇文章已翻译，可在公众号翻阅往期文章）。</p>
<h3><a class="header" href="#标记-traitmarker-traits" id="标记-traitmarker-traits">标记 Trait（Marker Traits）</a></h3>
<p>标记 trait 是不含 trait 项的 trait。它们的工作把实现类型“标记（mark）”为具有某种属性，否则就没有办法在类型系统中去表示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impling PartialEq for a type promises
// that equality for the type has these properties:
// - symmetry: a == b implies b == a, and
// - transitivity: a == b &amp;&amp; b == c implies a == c
// But DOES NOT promise this property:
// - reflexivity: a == a
trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;
}

// Eq has no trait items! The eq method is already
// declared by PartialEq, but &quot;impling&quot; Eq
// for a type promises this additional equality property:
// - reflexivity: a == a
trait Eq: PartialEq {}

// f64 impls PartialEq but not Eq because NaN != NaN
// i32 impls PartialEq &amp; Eq because there's no NaNs :)
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#自动-traitauto-trait" id="自动-traitauto-trait">自动 Trait（Auto Trait）</a></h3>
<p>自动 Trait 是指如果一个类型的所有成员都实现了该 trait，该类型就会自动实现该 trait。“成员（member）”的含义取决于类型，例如：结构体的字段、枚举的变量、数组的元素、元组的项，等等。</p>
<p>所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，所以编译器可以为它们提供一个自动的默认实现，如果它们有任何 trait 项，这就不可能实现了。</p>
<p>自动 trait 的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// implemented for types which are safe to send between threads
unsafe auto trait Send {}

// implemented for types whose references are safe to send between threads
unsafe auto trait Sync {}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#不安全-traitunsafe-trait" id="不安全-traitunsafe-trait">不安全 Trait（Unsafe Trait）</a></h3>
<p>Trait 可以被标记为 unsafe，以表明实现该 trait 可能需要 unsafe 代码。<code>Send</code>和<code>Sync</code>都被标记为 unsafe，因为如果它们不是自动实现的类型，就意味着它必须包含一些非<code>Send</code>或非<code>Sync</code>的成员，如果我们想手动标记类型为<code>Send</code>和<code>Sync</code>，作为实现者我们必须格外小心，确保没有数据竞争。</p>
<h2><a class="header" href="#自动-trait" id="自动-trait">自动 Trait</a></h2>
<h3><a class="header" href="#send--sync" id="send--sync">Send &amp; Sync</a></h3>
<p>所需预备知识</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe auto trait Send {}
unsafe auto trait Sync {}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型是<code>Send</code>，这就意味着它可以在线程之间被安全地发送（send）。如果一个类型是<code>Sync</code>，这就意味着它可以在线程间安全地共享引用。说得更准确点就是，当且仅当<code>&amp;T</code>是<code>Send</code>时，类型<code>T</code>是<code>Sync</code>。</p>
<p>几乎所有的类型都是<code>Send</code>和<code>Sync</code>。唯一值得注意的<code>Send</code>例外是<code>Rc</code>，<code>Sync</code>例外中需要注意的是<code>Rc</code>，<code>Cell</code>，<code>RefCell</code>。如果我们需要一个满足<code>Send</code>的<code>Rc</code>，我们可以使用<code>Arc</code>。如果我们需要一个<code>Cell</code>或<code>RefCell</code>的<code>Sync</code>版本，我们可以使用<code>Mutex</code>或<code>RwLock</code>。尽管我们使用<code>Mutex</code>和<code>RwLock</code>来包装一个原始类型，但通常来讲，使用标准库提供的原子类型会更好一些，比如<code>AtomicBool</code>，<code>AtomicI32</code>，<code>AtomicUsize</code>等等。</p>
<p>几乎所有的类型都是<code>Sync</code>这件事，可能会让一些人感到惊讶，但它是真的，即使是对于没有任何内部同步的类型来讲，也是如此。这能够得以实现要归功于 Rust 严格的借用规则。</p>
<p>我们可以传递同一份数据的若干个不可变引用到多个线程中，由于只要有不可变引用存在，Rust 就会静态地保证底层数据不被修改，所以我们可以保证不会发生数据竞争。</p>
<pre><pre class="playground"><code class="language-rust">use crossbeam::thread;

fn main() {
    let mut greeting = String::from(&quot;Hello&quot;);
    let greeting_ref = &amp;greeting;

    thread::scope(|scoped_thread| {
        // spawn 3 threads
        for n in 1..=3 {
            // greeting_ref copied into every thread
            scoped_thread.spawn(move |_| {
                println!(&quot;{} {}&quot;, greeting_ref, n); // prints &quot;Hello {n}&quot;
            });
        }

        // line below could cause UB or data races but compiler rejects it
        greeting += &quot; world&quot;; // ❌ cannot mutate greeting while immutable refs exist
    });

    // can mutate greeting after every thread has joined
    greeting += &quot; world&quot;; // ✅
    println!(&quot;{}&quot;, greeting); // prints &quot;Hello world&quot;
}
</code></pre></pre>
<p>同样地，我们可以把数据的一个可变引用传递给一个单独的线程，由于 Rust 静态地保证不存在可变引用的别名，所以底层数据不会通过另一个可变引用被修改，因此我们也可以保证不会发生数据竞争。</p>
<pre><pre class="playground"><code class="language-rust">use crossbeam::thread;

fn main() {
    let mut greeting = String::from(&quot;Hello&quot;);
    let greeting_ref = &amp;mut greeting;

    thread::scope(|scoped_thread| {
        // greeting_ref moved into thread
        scoped_thread.spawn(move |_| {
            *greeting_ref += &quot; world&quot;;
            println!(&quot;{}&quot;, greeting_ref); // prints &quot;Hello world&quot;
        });

        // line below could cause UB or data races but compiler rejects it
        greeting += &quot;!!!&quot;; // ❌ cannot mutate greeting while mutable refs exist
    });

    // can mutate greeting after the thread has joined
    greeting += &quot;!!!&quot;; // ✅
    println!(&quot;{}&quot;, greeting); // prints &quot;Hello world!!!&quot;
}
</code></pre></pre>
<p>这就是为什么大多数类型在不需要任何显式同步的情况下，都满足<code>Sync</code>的原因。当我们需要在多线程中同时修改某个数据<code>T</code>时，除非我们用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>或者<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>来包装这个数据，否则编译器是不会允许我们进行这种操作，所以编译器会在需要时强制要求进行显式地同步。</p>
<h3><a class="header" href="#sized" id="sized">Sized</a></h3>
<p>如果一个类型是<code>Sized</code>，这意味着它的类型大小在编译期是可知的，并且可以在栈上创建一个该类型的实例。</p>
<p>类型的大小及其含义是一个微妙而巨大的话题，影响到编程语言的许多方面。因为它十分重要，所以我单独写了一篇文章<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md" title="Sizedness in Rust">Sizedness in Rust</a>，如果有人想要更深入地了解 sizedness，我强烈推荐阅读这篇文章。我会把这篇文章的关键内容总结在下面。</p>
<ol>
<li>所有的泛型类型都有一个隐含的<code>Sized</code>约束。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn func&lt;T&gt;(t: &amp;T) {}

// example above desugared
fn func&lt;T: Sized&gt;(t: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>因为所有的泛型类型上都有一个隐含的<code>Sized</code>约束，如果我们想要选择退出这个约束，我们需要使用特定的“宽松约束（relaxed bound）”语法——<code>?Sized</code>，该语法目前只为<code>Sized</code> trait 存在。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// now T can be unsized
fn func&lt;T: ?Sized&gt;(t: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>所有的 trait 都有一个隐含的<code>?Sized</code>约束。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// example above desugared
trait Trait: ?Sized {}
<span class="boring">}
</span></code></pre></pre>
<p>这是为了让 trait 对象能够实现 trait，重申一下，所有的细枝末节都在<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">Sizedness in Rust</a>中。</p>
<h2><a class="header" href="#泛型-traits" id="泛型-traits">泛型 traits</a></h2>
<h3><a class="header" href="#default" id="default">Default</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>可以为实现了<code>Default</code>的类型构造默认值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color {
    r: u8,
    g: u8,
    b: u8,
}

impl Default for Color {
    // default color is black
    fn default() -&gt; Self {
        Color {
            r: 0,
            g: 0,
            b: 0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这在快速构建原型的时候十分有用，尤其是在我们没有过多要求而只需要一个类型实例的情况下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // just give me some color!
    let color = Color::default();
}
</code></pre></pre>
<p>当我们想要显式地把函数暴露给用户时，也可以选择这样做：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Canvas;
enum Shape {
    Circle,
    Rectangle,
}

impl Canvas {
    // let user optionally pass a color
    fn paint(&amp;mut self, shape: Shape, color: Option&lt;Color&gt;) {
        // if no color is passed use the default color
        let color = color.unwrap_or_default();
        // etc
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当我们需要构造泛型类型时，<code>Default</code>在泛型上下文中也是有用的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn guarantee_length&lt;T: Default&gt;(mut vec: Vec&lt;T&gt;, min_len: usize) -&gt; Vec&lt;T&gt; {
    for _ in 0..min_len.saturating_sub(vec.len()) {
        vec.push(T::default());
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>我们还可以利用<code>Default</code>类型结合 Rust 的结构体更新语法（struct update syntax）来对结构体部分初始化。现在，我们有一个<code>Color</code>结构体构造函数<code>new</code>，该函数接收结构体的所有成员作为参数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
    fn new(r: u8, g: u8, b: u8) -&gt; Self {
        Color {
            r,
            g,
            b,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>但是，我们可以有更为便利的构造函数，这些构造函数分别只接收结构体的一部分成员，结构体剩下的其他成员使用默认值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
    fn red(r: u8) -&gt; Self {
        Color {
            r,
            ..Color::default()
        }
    }
    fn green(g: u8) -&gt; Self {
        Color {
            g,
            ..Color::default()
        }
    }
    fn blue(b: u8) -&gt; Self {
        Color {
            b,
            ..Color::default()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>还有一个<code>Default</code>派生宏，通过使用它我们可以像下面这样来写<code>Color</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// default color is still black
// because u8::default() == 0
#[derive(Default)]
struct Color {
    r: u8,
    g: u8,
    b: u8
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#clone" id="clone">Clone</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Clone {
    fn clone(&amp;self) -&gt; Self;

    // provided default impls
    fn clone_from(&amp;mut self, source: &amp;Self);
}
<span class="boring">}
</span></code></pre></pre>
<p>我们能够把<code>Clone</code>类型的不可变引用转换为所拥有的值，即<code>&amp;T</code>-&gt;<code>T</code>。<code>Clone</code>不保证这种转换的效率，所以它会很慢并且成本较高。我们可以使用派生宏在一个类型上快速实现<code>Clone</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct SomeType {
    cloneable_member1: CloneableType1,
    cloneable_member2: CloneableType2,
    // etc
}

// macro generates impl below
impl Clone for SomeType {
    fn clone(&amp;self) -&gt; Self {
        SomeType {
            cloneable_member1: self.cloneable_member1.clone(),
            cloneable_member2: self.cloneable_member2.clone(),
            // etc
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Clone</code>可以用于在泛型上下文中构造一个类型实例。下面是从前面章节拿过来的一个例子，其中的<code>Default</code>被替换为了<code>Clone</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn guarantee_length&lt;T: Clone&gt;(mut vec: Vec&lt;T&gt;, min_len: usize, fill_with: &amp;T) -&gt; Vec&lt;T&gt; {
    for _ in 0..min_len.saturating_sub(vec.len()) {
        vec.push(fill_with.clone());
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>人们通常把克隆（clone）作为一种避免和借用检查器打交道的逃生出口（escape hatch）。管理带有引用的结构体很具有挑战性，但是我们可以通过克隆把引用变为所拥有的值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// oof, we gotta worry about lifetimes 😟
struct SomeStruct&lt;'a&gt; {
    data: &amp;'a Vec&lt;u8&gt;,
}

// now we're on easy street 😎
struct SomeStruct {
    data: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们正在编写的程序对性能不敏感，那么我们就不需要担心克隆数据的问题。Rust 是一门暴露了很多底层细节的语言，所以开发者很容易陷入过早的优化而非真正解决眼前的问题。对于很多程序来讲，最好的优先级顺序通常是，首先构建正确性，其次是优雅性，第三是性能，仅当在对性能进行剖析并确定性能瓶颈之后再去关注性能。通常而言，这是一个值得采纳的好建议，但是你需要清楚，它未必适用于你的程序。</p>
<h3><a class="header" href="#copy" id="copy">Copy</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy:Clone{}
<span class="boring">}
</span></code></pre></pre>
<p>我们拷贝<code>Copy</code>类型，例如：<code>T</code>-&gt;<code>T</code>.<code>Copy</code>承诺拷贝操作是简单的按位拷贝，所以它是快速高效的。我们不能自己实现<code>Copy</code>，只有编译器可以提供实现，但是我们可以通过使用<code>Copy</code>派生宏让编译器这么做，就像使用<code>Clone</code>派生宏一样，因为<code>Copy</code>是<code>Clone</code>的一个 subtrait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct SomeType;
<span class="boring">}
</span></code></pre></pre>
<p><code>Copy</code>对<code>Clone</code>进行了细化。一个克隆（clone）操作可能很慢并且开销很大，但是拷贝（copy）操作保证是快速且开销较小的，所以拷贝是一种更快的克隆操作。如果一个类型实现了<code>Copy</code>，<code>Clone</code>实现就无关紧要了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this is what the derive macro generates
impl&lt;T: Copy&gt; Clone for T {
    // the clone method becomes just a copy
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当一个类型实现了<code>Copy</code>之后，它在被移动（move）时的行为就发生了改变。默认情况下，所有的类型都有<em>移动（move）语义</em> ，但是一旦某个类型实现了<code>Copy</code>，它就有了<em>拷贝（copy）语义</em> 。为了解释二者的不同，让我们看一下这些简单的场景：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a &quot;move&quot;, src: !Copy
let dest = src;

// a &quot;copy&quot;, src: Copy
let dest = src;
<span class="boring">}
</span></code></pre></pre>
<p>在上面两种情况下，<code>dest = src</code>对<code>src</code>的内容进行按位拷贝并把结果移动到<code>dest</code>，唯一的不同是，在第一种情况（&quot;a move&quot;）中，借用检查器使得<code>src</code>变量失效并确保它后面不会在任何其他地方被使用;在第二种情况下（&quot;a copy&quot;）中，<code>src</code>仍然是有效且可用的。</p>
<p>简而言之：拷贝就是移动，移动就是拷贝。它们之间唯一的区别就是其对待借用检查器的方式。</p>
<p>来看一个关于移动（move）的更具体的例子，假定<code>sec</code>是一个<code>Vec&lt;i32&gt;</code>类型，并且它的内容看起来像下面这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ data: *mut [i32], length: usize, capacity: usize }
<span class="boring">}
</span></code></pre></pre>
<p>当我们执行了<code>dest = src</code>，我们会得到：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src = { data: *mut [i32], length: usize, capacity: usize }
dest = { data: *mut [i32], length: usize, capacity: usize }
<span class="boring">}
</span></code></pre></pre>
<p>在这个未知，<code>src</code>和<code>dest</code>对同一份数据各有一个可变引用别名，这是一个大忌，因此，借用检查器让<code>src</code>变量失效，在编译器不报错的情况下。使得它不能再被使用。</p>
<p>再来看一个关于拷贝（copy）的更具体的例子，假定<code>src</code>是一个<code>Option&lt;i32&gt;</code>，且它的内容看起来如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ is_valid: bool, data: i32 }
<span class="boring">}
</span></code></pre></pre>
<p>现在，当我们执行<code>dest = src</code>时，我们会得到：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src = { is_valid: bool, data: i32 }
dest = { is_valid: bool, data: i32 }
<span class="boring">}
</span></code></pre></pre>
<p>它们俩同时都是可用的！因此，<code>Option&lt;i32&gt;</code>是<code>Copy</code>。</p>
<p>尽管<code>Copy</code>是一个自动 trait，但是 Rust 语言设计者决定，让类型显式地选择拷贝语义，而不是在类型符合条件时默默地继承拷贝语义，因为后者可能会引起经常导致 bug 的混乱行为。</p>
<h3><a class="header" href="#any" id="any">Any</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Any: 'static {
    fn type_id(&amp;self) -&gt; TypeId;
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 的多态风格是参数化的，但是如果我们正在尝试使用一种类似于动态类型语言的更为特别（ad-hoc）的多态风格，那么我们可以通过使用<code>Any</code> trait 来进行模拟。我们不必手动为我们的类型实现<code>Any</code> trait，因为这已经被 generic blanket impl 所涵盖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: 'static + ?Sized&gt; Any for T {
    fn type_id(&amp;self) -&gt; TypeId {
        TypeId::of::&lt;T&gt;()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>我们通过使用<code>downcast_ref::&lt;T&gt;()</code>和<code>downcast_mut::&lt;T&gt;()</code>方法从一个<code>dyn Any</code>中拿出一个<code>T</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&amp;mut self) {
        self.x += 1;
        self.y += 1;
    }
}

fn map_any(mut any: Box&lt;dyn Any&gt;) -&gt; Box&lt;dyn Any&gt; {
    if let Some(num) = any.downcast_mut::&lt;i32&gt;() {
        *num += 1;
    } else if let Some(string) = any.downcast_mut::&lt;String&gt;() {
        *string += &quot;!&quot;;
    } else if let Some(point) = any.downcast_mut::&lt;Point&gt;() {
        point.inc();
    }
    any
}

fn main() {
    let mut vec: Vec&lt;Box&lt;dyn Any&gt;&gt; = vec![
        Box::new(0),
        Box::new(String::from(&quot;a&quot;)),
        Box::new(Point::default()),
    ];
    // vec = [0, &quot;a&quot;, Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_any).collect();
    // vec = [1, &quot;a!&quot;, Point { x: 1, y: 1 }]
}
</code></pre></pre>
<p>这个 trait 很少需要用到，因为在大多数情况下，参数化多态要优于临时多态性，后者也可以用枚举（enum）来模拟，枚举具有更好的类型安全，需要的间接（抽象）也更少。例如，我们可以用下面的方式实现上面的例子：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&amp;mut self) {
        self.x += 1;
        self.y += 1;
    }
}

enum Stuff {
    Integer(i32),
    String(String),
    Point(Point),
}

fn map_stuff(mut stuff: Stuff) -&gt; Stuff {
    match &amp;mut stuff {
        Stuff::Integer(num) =&gt; *num += 1,
        Stuff::String(string) =&gt; *string += &quot;!&quot;,
        Stuff::Point(point) =&gt; point.inc(),
    }
    stuff
}

fn main() {
    let mut vec = vec![
        Stuff::Integer(0),
        Stuff::String(String::from(&quot;a&quot;)),
        Stuff::Point(Point::default()),
    ];
    // vec = [0, &quot;a&quot;, Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_stuff).collect();
    // vec = [1, &quot;a!&quot;, Point { x: 1, y: 1 }]
}

</code></pre></pre>
<p>尽管<code>Any</code>很少被需要用到，但是在某些时候它也会十分地便利，正如我们在后面错误处理（Error Handling）部分所看到的那样。</p>
<h2><a class="header" href="#格式化-traits-formatting-traits" id="格式化-traits-formatting-traits">格式化 Traits (Formatting Traits)</a></h2>
<p>我们可以使用<code>std::fmt</code>中的格式化宏来把类型序列化(serialize)为字符串，其中最为我们熟知的就是<code>println!</code>。我们可以把格式化参数传递给<code>{}</code>占位符，这些占位符用于选择使用哪个 trait 来序列化占位符参数。</p>
<table><thead><tr><th>Trait</th><th>Placeholder</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Display</code></td><td><code>{}</code></td><td>显示表示</td></tr>
<tr><td><code>Debug</code></td><td><code>{:?}</code></td><td>调试表示</td></tr>
<tr><td><code>Octal</code></td><td><code>{:o}</code></td><td>八进制表示</td></tr>
<tr><td><code>LowerHex</code></td><td><code>{:x}</code></td><td>小写十六进制表示</td></tr>
<tr><td><code>UpperHex</code></td><td><code>{:X}</code></td><td>大写十六进制表示</td></tr>
<tr><td><code>Pointer</code></td><td><code>{:p}</code></td><td>内存地址</td></tr>
<tr><td><code>Binary</code></td><td><code>{:b}</code></td><td>二进制表示</td></tr>
<tr><td><code>LowerExp</code></td><td><code>{:e}</code></td><td>小写指数表示</td></tr>
<tr><td><code>UpperExp</code></td><td><code>{:E}</code></td><td>大写指数表示</td></tr>
</tbody></table>
<h3><a class="header" href="#display--tostring" id="display--tostring">Display &amp; ToString</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Display</code>类型可以被序列化为对用户更为友好的<code>String</code>类型。以<code>Point</code>类型为列：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}

fn main() {
    println!(&quot;origin: {}&quot;, Point::default());
    // prints &quot;origin: (0, 0)&quot;

    // get Point's Display representation as a String
    let stringified_point = format!(&quot;{}&quot;, Point::default());
    assert_eq!(&quot;(0, 0)&quot;, stringified_point); // ✅
}
</code></pre></pre>
<p>除了使用<code>format!</code>宏让一个类型以<code>String</code>类型显示，我们还可以使用<code>ToString</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>这个 trait 不需要我们实现，事实上，由于 generic blanket impl，我们也不能去实现它，因为所有实现了<code>Display</code>的类型都会自动实现<code>ToString</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display + ?Sized&gt; ToString for T;
<span class="boring">}
</span></code></pre></pre>
<p>在<code>Point</code>上使用<code>ToString</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test] // ✅
fn display_point() {
    let origin = Point::default();
    assert_eq!(format!(&quot;{}&quot;, origin), &quot;(0, 0)&quot;);
}

#[test] // ✅
fn point_to_string() {
    let origin = Point::default();
    assert_eq!(origin.to_string(), &quot;(0, 0)&quot;);
}

#[test] // ✅
fn display_equals_to_string() {
    let origin = Point::default();
    assert_eq!(format!(&quot;{}&quot;, origin), origin.to_string());
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#debug" id="debug">Debug</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Debug</code>和<code>Display</code>有着相同的签名。唯一的不同在于，只有当我门指定了<code>{:?}</code>才会调用<code>Debug</code>实现。<code>Debug</code>可以被派生：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// derive macro generates impl below
impl fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_struct(&quot;Point&quot;)
            .field(&quot;x&quot;, &amp;self.x)
            .field(&quot;y&quot;, &amp;self.y)
            .finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为一个类型实现<code>Debug</code>能够使得这个类型在<code>dbg!</code>中使用，<code>dbg!</code>宏在快速打印日志方面比<code>println!</code>更合适，它的一些优势如下：</p>
<ol>
<li><code>dbg!</code>打印到 stderr 而不是 stdout，因此在我们的程序中，能够很容易地和标准输出的输出结果区分。</li>
<li><code>dbg!</code>会连同传入的表达式和表达式的计算结果一起打印出来。</li>
<li><code>dbg!</code>会获取传入参数的所有权并将其返回，因此你可以在表达式中使用它：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_condition() -&gt; bool {
    true
}

// no logging
fn example() {
    if some_condition() {
        // some code
    }
}

// println! logging
fn example_println() {
    // 🤦
    let result = some_condition();
    println!(&quot;{}&quot;, result); // just prints &quot;true&quot;
    if result {
        // some code
    }
}

// dbg! logging
fn example_dbg() {
    // 😍
    if dbg!(some_condition()) { // prints &quot;[src/main.rs:22] some_condition() = true&quot;
        // some code
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><code>dbg!</code>的唯一缺点就是它不会在 release 构建中自动裁剪，所以如果我们不想在最后生成的二进制包含这些内容，就必须手动移除它。</p>
<h2><a class="header" href="#操作符-traitoperator-traits" id="操作符-traitoperator-traits">操作符 Trait（Operator Traits）</a></h2>
<p>Rust 中所有的操作符都和 trait 关联，如果我们想要为我们的类型实现一些操作符，我们就必须实现与之关联的 trait。
| Trait(s) | 分类（Category） | 操作符（Operator(s)） | 描述（Description） |
|----------|----------|-------------|-------------|
| <code>Eq</code>, <code>PartialEq</code> | 比较 | <code>==</code> | 相等 |
| <code>Ord</code>, <code>PartialOrd</code> | 比较 | <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> | 比较 |
| <code>Add</code> | 算术 | <code>+</code> | 相加 |
| <code>AddAssign</code> | 算术 | <code>+=</code> | 相加并赋值 |
| <code>BitAnd</code> | 算术 | <code>&amp;</code> | 按位与 |
| <code>BitAndAssign</code> | 算术 | <code>&amp;=</code> | 按位与并赋值 |
| <code>BitXor</code> | 算术 | <code>^</code> | 按位异或 |
| <code>BitXorAssign</code> | 算术 | <code>^=</code> | 按位异或并赋值 |
| <code>Div</code> | 算术 | <code>/</code> | 除 |
| <code>DivAssign</code> | 算术 | <code>/=</code> | 除并赋值 |
| <code>Mul</code> | 算术 | <code>*</code> | 乘 |
| <code>MulAssign</code> | 算术 | <code>*=</code> | 乘并赋值 |
| <code>Neg</code> | 算术 | <code>-</code> | 一元求反 |
| <code>Not</code> | 算术 | <code>!</code> | 一元逻辑求反 |
| <code>Rem</code> | 算术 | <code>%</code> | 求余 |
| <code>RemAssign</code> | 算术 | <code>%=</code> | 求余并赋值|
| <code>Shl</code> | 算术 | <code>&lt;&lt;</code> | 左移 |
| <code>ShlAssign</code> | 算术 | <code>&lt;&lt;=</code> | 左移并赋值 |
| <code>Shr</code> | 算术 | <code>&gt;&gt;</code> | 右移 |
| <code>ShrAssign</code> | 算术 | <code>&gt;&gt;=</code> | 右移并赋值 |
| <code>Sub</code> | 算术 | <code>-</code> | 减 |
| <code>SubAssign</code> | 算术 | <code>-=</code> | 减并赋值 |
| <code>Fn</code> | 闭包 | <code>(...args)</code> | 不可变闭包调用 |
| <code>FnMut</code> | 闭包 | <code>(...args)</code> | 可变闭包调用 |
| <code>FnOnce</code> | 闭包 | <code>(...args)</code> | 一次性闭包调用 |
| <code>Deref</code> | 其他 | <code>*</code> | 不可变解引用 |
| <code>DerefMut</code> | 其他 | <code>*</code> | 可变解引用 |
| <code>Drop</code> | 其他 | - | 类型析构 |
| <code>Index</code> | 其他 | <code>[]</code> | 不可变索引 |
| <code>IndexMut</code> | 其他 | <code>[]</code> |可变索引|
| <code>RangeBounds</code> | 其他 | <code>..</code> | 区间 |</p>
<h3><a class="header" href="#比较-trait-comparison-traits" id="比较-trait-comparison-traits">比较 Trait （Comparison Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Eq</code>, <code>PartialEq</code></td><td>比较</td><td><code>==</code></td><td>相等</td></tr>
<tr><td><code>Ord</code>, <code>PartialOrd</code></td><td>比较</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>比较</td></tr>
</tbody></table>
<h4><a class="header" href="#partialeq--eq" id="partialeq--eq">PartialEq &amp; Eq</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PartialEq&lt;Rhs = Self&gt;
where
    Rhs: ?Sized,
{
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    // provided default impls
    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>PartialEq&lt;Rhs&gt;</code>类型可以通过<code>==</code>操作符检查是否和<code>Rhs</code>类型相等。</p>
<p>所有的<code>PartialEq&lt;Rhs&gt;</code>实现必须确保相等性是对称的和可传递的。这意味着，对于任意的<code>a</code>、<code>b</code>、<code>c</code>:</p>
<ul>
<li><code>a == b</code>也意味着<code>b == a</code>（对称性）</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> （传递性）</li>
</ul>
<p>默认情况下，<code>Rhs = Self</code>，因为我们几乎总是想要比较同一类型的不同实例，而不是不同类型的不同实例。这也保证了我们的实现是对称的和可传递的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32
}

// Rhs == Self == Point
impl PartialEq for Point {
    // impl automatically symmetric &amp; transitive
    fn eq(&amp;self, other: &amp;Point) -&gt; bool {
        self.x == other.x &amp;&amp; self.y == other.y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型的所有成员都实现了<code>PartialEq</code>，则它会派生实现<code>PartialEq</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Point {
    x: i32,
    y: i32
}

#[derive(PartialEq)]
enum Suit {
    Spade,
    Heart,
    Club,
    Diamond,
}

<span class="boring">}
</span></code></pre></pre>
<p>一旦我们为自己的类型实现了<code>PartialEq</code>，我们就能够轻松地在类型的引用之间进行相等性比较，这要归功于 generic blanket impls：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this impl only gives us: Point == Point
#[derive(PartialEq)]
struct Point {
    x: i32,
    y: i32
}

// all of the generic blanket impls below
// are provided by the standard library

// this impl gives us: &amp;Point == &amp;Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ B&gt; for &amp;'_ A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;mut Point == &amp;Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ B&gt; for &amp;'_ mut A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;Point == &amp;mut Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ mut B&gt; for &amp;'_ A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;mut Point == &amp;mut Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ mut B&gt; for &amp;'_ mut A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

<span class="boring">}
</span></code></pre></pre>
<p>因为这个 trait 是泛型的，所以我们可以在不同的类型之间定义相等性（比较）。标准库利用这一点实现了类字符串类型之间的相互比较，比如<code>String</code>、<code>&amp;str</code>、<code>PathBuf</code>、<code>&amp;Path</code>、<code>OsString</code>、<code>&amp;OsStr</code>等等。</p>
<p>通常，我们应该仅为特定的不同类型之间实现相等性，这些不同类型包含了相同类型的数据，并且它们之间唯一的区别是表现数据的方式和与数据交互的方式。</p>
<p>下面是一个反面实例，关于某人试图在没有满足上述规则的不同类型之间实现<code>PartialEq</code>用以检查完整性的例子：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq)]
enum Suit {
    Spade,
    Club,
    Heart,
    Diamond,
}

#[derive(PartialEq)]
enum Rank {
    Ace,
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
}

#[derive(PartialEq)]
struct Card {
    suit: Suit,
    rank: Rank,
}

// check equality of Card's suit
impl PartialEq&lt;Suit&gt; for Card {
    fn eq(&amp;self, other: &amp;Suit) -&gt; bool {
        self.suit == *other
    }
}

// check equality of Card's rank
impl PartialEq&lt;Rank&gt; for Card {
    fn eq(&amp;self, other: &amp;Rank) -&gt; bool {
        self.rank == *other
    }
}

fn main() {
    let AceOfSpades = Card {
        suit: Suit::Spade,
        rank: Rank::Ace,
    };
    assert!(AceOfSpades == Suit::Spade); // ✅
    assert!(AceOfSpades == Rank::Ace); // ✅
}

</code></pre></pre>
<p><code>Eq</code>是一个标记 trait，并且是<code>PartialEq&lt;Self&gt;</code>的一个 subtrait。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Eq: PartialEq&lt;Self&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们为一个类型实现了<code>Eq</code>，在<code>PartialEq</code>所要求的对称性和可传递性之上，我们还保证了反射性（reflexivity），也就是对于任意的<code>a</code>，都有<code>a == a</code>。从这种意义上来说，<code>Eq</code>对<code>PartialEq</code>进行了细化，因为它表示了一个更为严格的相等性。如果一个类型的所有成员都实现了<code>Eq</code>，那么<code>Eq</code>的实现可以派生到这个类型。</p>
<p>浮点型实现了<code>PartialEq</code>但是没有实现<code>Eq</code>，因为<code>NaN != NaN</code>。几乎所有其他的实现了<code>PartialEq</code>的类型都实现了<code>Eq</code>，除非它们包含浮点类型。</p>
<p>一旦一个类型实现了<code>PartialEq</code>和<code>Debug</code>，我们可以就可以在<code>assert_eq!</code>宏中使用它。我们还可以比较实现了<code>PartialEq</code>类型的集合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn example_assert(p1: Point, p2: Point) {
    assert_eq!(p1, p2);
}

fn example_compare_collections&lt;T: PartialEq&gt;(vec1: Vec&lt;T&gt;, vec2: Vec&lt;T&gt;) {
    // if T: PartialEq this now works!
    if vec1 == vec2 {
        // some code
    } else {
        // other code
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#hash" id="hash">Hash</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hash {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H);

    // provided default impls
    fn hash_slice&lt;H: Hasher&gt;(data: &amp;[Self], state: &amp;mut H);
}
<span class="boring">}
</span></code></pre></pre>
<p>这个 trait 没有与任何操作符关联，但是讨论它的最好时机就是在<code>PartialEq</code>和<code>Eq</code>之后，所以把它写在这里。<code>Hash</code>类型可以通过一个<code>Hasher</code>被（计算）哈希。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::Hasher;
use std::hash::Hash;

struct Point {
    x: i32,
    y: i32,
}

impl Hash for Point {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        hasher.write_i32(self.x);
        hasher.write_i32(self.y);
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>使用派生宏可以生成和上面一样的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Point {
    x: i32,
    y: i32,
}

<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型同时实现了<code>Hash</code>和<code>Eq</code>，那么这些实现必须达成一致，从而保证对于所有的<code>a</code>和<code>b</code>，如果<code>a == b</code>那么<code>a.hash() == b.hash()</code>。因此，当为一个类型同时实现这两个 trait 时，要么都用派生宏，要么都手动实现，但是不要混合，否则我们就有可能破坏上面的不变性。</p>
<p>为一个类型实现<code>Eq</code>和<code>Hash</code>的最大好处是，它让我们能够把类型作为 key 存储在<code>HashMap</code>和<code>HashSet</code>中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

// now our type can be stored
// in HashSets and HashMaps!
#[derive(PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}

fn example_hashset() {
    let mut points = HashSet::new();
    points.insert(Point { x: 0, y: 0 }); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#partialord--ord" id="partialord--ord">PartialOrd &amp; Ord</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Ordering {
    Less,
    Equal,
    Greater,
}

trait PartialOrd&lt;Rhs = Self&gt;: PartialEq&lt;Rhs&gt;
where
    Rhs: ?Sized,
{
    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;;

    // provided default impls
    fn lt(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn le(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn gt(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn ge(&amp;self, other: &amp;Rhs) -&gt; bool;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>PartialOrd&lt;Rhs&gt;</code>类型可以通过<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>操作符和<code>Rhs</code>类型比较。所有的<code>PartialOrd&lt;Rhs&gt;</code>实现必须保证比较时非对称和可传递的。这意味着，对于任意的<code>a</code>、<code>b</code>和<code>c</code>：</p>
<ul>
<li><code>a &lt; b</code>意味着<code>!(a&gt;b)</code>（非对称性）</li>
<li><code>a &lt; b &amp;&amp; b &lt; c</code> 意味着<code>a &lt; c</code>(传递性)</li>
</ul>
<p><code>PartialOrd</code>是<code>PartialEq</code>的一个 subtrait，并且它们的实现必须相互一致。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn must_always_agree&lt;T: PartialOrd + PartialEq&gt;(t1: T, t2: T) {
    assert_eq!(t1.partial_cmp(&amp;t2) == Some(Ordering::Equal), t1 == t2);
}

<span class="boring">}
</span></code></pre></pre>
<p>当比较<code>PartialEq</code>类型时，我们可以检查是否它们相等或者不相等，但是当比较<code>PartialOrd</code>类型时，我们除了可以检查是否它们相等或不相等自己哦之外，如果它们不相等，我们还可以检查它们不相等是因为第一项小于第二项或者是第一项大于第二项。</p>
<p>默认情况下，<code>Rhs == Self</code>，因为我们总是想要比较同一类型的实例，而不是对不同类型的实例。这也自动保证了我们的实现是对称的和可传递的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32
}

// Rhs == Self == Point
impl PartialOrd for Point {
    // impl automatically symmetric &amp; transitive
    fn partial_cmp(&amp;self, other: &amp;Point) -&gt; Option&lt;Ordering&gt; {
        Some(match self.x.cmp(&amp;other.x) {
            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
            ordering =&gt; ordering,
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型的所有成员都实现了<code>PartialOrd</code>，那么它就可以被派生：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(PartialEq, PartialOrd)]
enum Stoplight {
    Red,
    Yellow,
    Green,
}
<span class="boring">}
</span></code></pre></pre>
<p>派生宏<code>PartialOrd</code>根据字典序（lexicographical）对它们的成员进行排序：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// generates PartialOrd impl which orders
// Points based on x member first and
// y member second because that's the order
// they appear in the source code
#[derive(PartialOrd, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// generates DIFFERENT PartialOrd impl
// which orders Points based on y member
// first and x member second
#[derive(PartialOrd, PartialEq)]
struct Point {
    y: i32,
    x: i32,
}

<span class="boring">}
</span></code></pre></pre>
<p><code>Ord</code>是<code>Eq</code>和<code>PartialOrd&lt;Self&gt;</code>的一个 subtrait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Ord: Eq + PartialOrd&lt;Self&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;

    // provided default impls
    fn max(self, other: Self) -&gt; Self;
    fn min(self, other: Self) -&gt; Self;
    fn clamp(self, min: Self, max: Self) -&gt; Self;
}

<span class="boring">}
</span></code></pre></pre>
<p>如果我们为一个类型实现了<code>Ord</code>，在<code>PartialOrd</code>保证了非对称性和传递性之上，我们还能保证整体的非对称性，即对于任意给定的<code>a</code>、<code>b</code>，<code>a &lt; b</code>、<code>a == b</code>或<code>a &gt; b</code>中必有一个为真。从这个角度来讲，<code>Ord</code>细化了<code>Eq</code>和<code>PartialOrd</code>，因为它表示一个更严格的比较。如果一个类型实现了<code>Ord</code>，我们就可以利用这个实现来实现<code>PartialOrd</code>、<code>PartialEq</code>和<code>Eq</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

// of course we can use the derive macros here
#[derive(Ord, PartialOrd, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// note: as with PartialOrd, the Ord derive macro
// orders a type based on the lexicographical order
// of its members

// but here's the impls if we wrote them out by hand
impl Ord for Point {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        match self.x.cmp(&amp;other.x) {
            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
            ordering =&gt; ordering,
        }
    }
}
impl PartialOrd for Point {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}
impl PartialEq for Point {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.cmp(other) == Ordering::Equal
    }
}
impl Eq for Point {}

<span class="boring">}
</span></code></pre></pre>
<p>浮点型实现了<code>PartialOrd</code>但是没有实现<code>Ord</code>，因为<code>NaN &lt; 0 == false</code>和<code>NaN &gt;= 0 == false</code>都为真。几乎所有的其他的<code>PartialOrd</code>类型都实现了<code>Ord</code>，除非它们中包含有浮点型。</p>
<p>一旦一个类型实现了<code>Ord</code>，我们就可以把它存储在<code>BTreeMap</code>和<code>BTreeSet</code>，还可以在 slice 上使用 sort()方法对其进行排序，这同样适用于其他可以解引用为 slice 的类型，比如数组、<code>Vec</code>和<code>VecDeque</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BTreeSet;

// now our type can be stored
// in BTreeSets and BTreeMaps!
#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

fn example_btreeset() {
    let mut points = BTreeSet::new();
    points.insert(Point { x: 0, y: 0 }); // ✅
}

// we can also .sort() Ord types in collections!
fn example_sort&lt;T: Ord&gt;(mut sortable: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    sortable.sort();
    sortable
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#算术-traitarithmetic-traits" id="算术-traitarithmetic-traits">算术 Trait（Arithmetic Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Add</code></td><td>算术</td><td><code>+</code></td><td>相加</td></tr>
<tr><td><code>AddAssign</code></td><td>算术</td><td><code>+=</code></td><td>相加并赋值</td></tr>
<tr><td><code>BitAnd</code></td><td>算术</td><td><code>&amp;</code></td><td>按位与</td></tr>
<tr><td><code>BitAndAssign</code></td><td>算术</td><td><code>&amp;=</code></td><td>按位与并赋值</td></tr>
<tr><td><code>BitXor</code></td><td>算术</td><td><code>^</code></td><td>按位异或</td></tr>
<tr><td><code>BitXorAssign</code></td><td>算术</td><td><code>^=</code></td><td>按位异或并赋值</td></tr>
<tr><td><code>Div</code></td><td>算术</td><td><code>/</code></td><td>除</td></tr>
<tr><td><code>DivAssign</code></td><td>算术</td><td><code>/=</code></td><td>除并赋值</td></tr>
<tr><td><code>Mul</code></td><td>算术</td><td><code>*</code></td><td>乘</td></tr>
<tr><td><code>MulAssign</code></td><td>算术</td><td><code>*=</code></td><td>乘并赋值</td></tr>
<tr><td><code>Neg</code></td><td>算术</td><td><code>-</code></td><td>一元求反</td></tr>
<tr><td><code>Not</code></td><td>算术</td><td><code>!</code></td><td>一元逻辑求反</td></tr>
<tr><td><code>Rem</code></td><td>算术</td><td><code>%</code></td><td>求余</td></tr>
<tr><td><code>RemAssign</code></td><td>算术</td><td><code>%=</code></td><td>求余并赋值</td></tr>
<tr><td><code>Shl</code></td><td>算术</td><td><code>&lt;&lt;</code></td><td>左移</td></tr>
<tr><td><code>ShlAssign</code></td><td>算术</td><td><code>&lt;&lt;=</code></td><td>左移并赋值</td></tr>
<tr><td><code>Shr</code></td><td>算术</td><td><code>&gt;&gt;</code></td><td>右移</td></tr>
<tr><td><code>ShrAssign</code></td><td>算术</td><td><code>&gt;&gt;=</code></td><td>右移并赋值</td></tr>
<tr><td><code>Sub</code></td><td>算术</td><td><code>-</code></td><td>减</td></tr>
<tr><td><code>SubAssign</code></td><td>算术</td><td><code>-=</code></td><td>减并赋值</td></tr>
</tbody></table>
<p>我们没有必要把所有的算术操作符都仔细看一遍，毕竟它们中大多数都只作用于数值类型。我们将会讨论<code>Add</code>和<code>AddAssign</code>，因为<code>+</code>操作符经常被重载用来完成其他事情，比如往集合里添加一项，或者进行拼接操作，这样我们就可以从最有趣的地方入手而不会重复。</p>
<h4><a class="header" href="#add--addassign" id="add--addassign">Add &amp; AddAssign</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Add&lt;Rhs, Output = T&gt;</code>类型可以被加到<code>Rhs</code>类型上并产生一个<code>T</code>作为输出。</p>
<p>例如，在<code>Point</code>上实现<code>Add&lt;Point, Output = Point&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1 + p2;
    assert_eq!(p3.x, p1.x + p2.x); // ✅
    assert_eq!(p3.y, p1.y + p2.y); // ✅
}

</code></pre></pre>
<p>但是，如果我们只有<code>Point</code>的引用，那该怎么办呢？我们还能把它们相加么？让我们试试：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &amp;p1 + &amp;p2; // ❌
}
</code></pre></pre>
<p>显然不可以，编译器抛出下面的提示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0369]: cannot add `&amp;Point` to `&amp;Point`
  --&gt; src/main.rs:50:25
   |
50 |     let p3: Point = &amp;p1 + &amp;p2;
   |                     --- ^ --- &amp;Point
   |                     |
   |                     &amp;Point
   |
   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`

<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 的类型系统中，对于某个类型<code>T</code>，<code>T</code>、<code>&amp;T</code>、<code>&amp;mut T</code>都会被视作是完全不同的类型，这意味着我们必须分别为它们提供 trait 的实现。让我们为<code>&amp;Point</code>实现<code>Add</code>：</p>
<pre><pre class="playground"><code class="language-rust">impl Add for &amp;Point {
    type Output = Point;
    fn add(self, rhs: &amp;Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &amp;p1 + &amp;p2; // ✅
    assert_eq!(p3.x, p1.x + p2.x); // ✅
    assert_eq!(p3.y, p1.y + p2.y); // ✅
}

</code></pre></pre>
<p>尽管如此，但是仍然感觉有些地方不太对。我们针对<code>Point</code>和<code>&amp;Point</code>实现了两份<code>Add</code>，它们恰好目前还做了相同的事情，但是我们不能保证将来也是如此。例如，假设我们决定，当我们把两个<code>Point</code>相加时，我们想要创建一个包含这两个<code>Point</code>的<code>Line</code>类型而不是创建一个新的<code>Point</code>，那么我们会把<code>Add</code>的实现更新：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(Copy, Clone)]
struct Line {
    start: Point,
    end: Point,
}

// we updated this impl
impl Add for Point {
    type Output = Line;
    fn add(self, rhs: Point) -&gt; Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

// but forgot to update this impl, uh oh!
impl Add for &amp;Point {
    type Output = Point;
    fn add(self, rhs: &amp;Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = p1 + p2; // ✅

    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = &amp;p1 + &amp;p2; // ❌ expected Line, found Point
}

</code></pre></pre>
<p>我们当前针对<code>&amp;Point</code>的<code>Add</code>实现就产生了一个不必要的维护负担，我们希望这个实现能够自动匹配<code>Point</code>的实现而无需我们每次在修改<code>Point</code>的实现时都手动维护更新。我们想要保持我们的代码尽可能地 DRY（Don't Repeat Yourself，不要重复自己）。幸运的是这是可以实现的：</p>
<pre><pre class="playground"><code class="language-rust">// updated, DRY impl
impl Add for &amp;Point {
    type Output = &lt;Point as Add&gt;::Output;
    fn add(self, rhs: &amp;Point) -&gt; Self::Output {
        Point::add(*self, *rhs)
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = p1 + p2; // ✅

    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = &amp;p1 + &amp;p2; // ✅
}

</code></pre></pre>
<p><code>AddAssign&lt;Rhs&gt;</code>类型能够让我们和<code>Rhs</code>类型相加并赋值。该 trait 声明如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AddAssign&lt;Rhs = Self&gt; {
    fn add_assign(&amp;mut self, rhs: Rhs);
}
<span class="boring">}
</span></code></pre></pre>
<p>以<code>Point</code>和<code>&amp;Point</code>为例：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::AddAssign;

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32
}

impl AddAssign for Point {
    fn add_assign(&amp;mut self, rhs: Point) {
        self.x += rhs.x;
        self.y += rhs.y;
    }
}

impl AddAssign&lt;&amp;Point&gt; for Point {
    fn add_assign(&amp;mut self, rhs: &amp;Point) {
        Point::add_assign(self, *rhs);
    }
}

fn main() {
    let mut p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    p1 += &amp;p2;
    p1 += p2;
    assert!(p1.x == 7 &amp;&amp; p1.y == 10);
}

</code></pre></pre>
<h3><a class="header" href="#闭包-traitclosure-traits" id="闭包-traitclosure-traits">闭包 Trait（Closure Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Fn</code></td><td>闭包</td><td><code>(...args)</code></td><td>不可变闭包调用</td></tr>
<tr><td><code>FnMut</code></td><td>闭包</td><td><code>(...args)</code></td><td>可变闭包调用</td></tr>
<tr><td><code>FnOnce</code></td><td>闭包</td><td><code>(...args)</code></td><td>一次性闭包调用</td></tr>
</tbody></table>
<h4><a class="header" href="#fnonce-fnmut--fn" id="fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FnOnce&lt;Args&gt; {
    type Output;
    fn call_once(self, args: Args) -&gt; Self::Output;
}

trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    fn call(&amp;self, args: Args) -&gt; Self::Output;
}

<span class="boring">}
</span></code></pre></pre>
<p>虽然存在这些 trait，但是在 stable 的 Rust 中，我们无法为自己的类型实现这些 trait。我们能够创建的唯一能够实现这些 trait 的类型就是闭包。闭包根据其从环境中所捕获的内容来决定它到底是实现<code>FnOnce</code>、<code>FnMut</code>还是<code>Fn</code>。</p>
<p><code>FnOnce</code>闭包只能被调用一次，因为它会在执行过程中消耗掉某些值:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let range = 0..10;
    let get_range_count = || range.count();
    assert_eq!(get_range_count(), 10); // ✅
    get_range_count(); // ❌
}

</code></pre></pre>
<p>迭代器上的<code>.count()</code>方法会消耗迭代器，因此它只能被调用一次。因此，我们的闭包也只能调用一次。这也是为什么我们在尝试调用第二次的时候会得到下面的错误：</p>
<pre><code class="language-shell">error[E0382]: use of moved value: `get_range_count`
 --&gt; src/main.rs:5:5
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ----------------- `get_range_count` moved due to this call
5 |     get_range_count();
  |     ^^^^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `range` out of its environment
 --&gt; src/main.rs:3:30
  |
3 |     let get_range_count = || range.count();
  |                              ^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; src/main.rs:4:16
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ^^^^^^^^^^^^^^^

</code></pre>
<p><code>FnMut</code>闭包可以被多次调用，并且可以修改它从环境中捕获到的变量。我们可以说<code>FnMut</code>有副作用或者是有状态的（stateful）。下面是一个闭包的示例，通过从迭代器中追踪它见到的最小值来过滤所有非升序的值。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
    let mut min = i32::MIN;
    let ascending = nums.into_iter().filter(|&amp;n| {
        if n &lt;= min {
            false
        } else {
            min = n;
            true
        }
    }).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(vec![0, 4, 8, 10, 15, 18], ascending); // ✅
}

</code></pre></pre>
<p><code>FnOnce</code>会获取它的参数的所有权并且只能被调用一次，但是<code>FnMut</code>仅要求获取参数的可变引用并且可以被多次调用，从这一点上来讲，<code>FnMut</code>细化了<code>FnOnce</code>。<code>FnMut</code>可以被用于任何可以使用<code>FnOnce</code>的地方。</p>
<p><code>Fn</code>闭包也可以被调用多次，但是它不能修改从环境中捕获的变量。我们可以说，<code>Fn</code>闭包没有副作用或者无状态的（stateless）。下面是一个示例，从一个迭代器中过滤出所有小于某个栈上变量的数字，该变量是它是环境中捕获到的：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
    let min = 9;
    let greater_than_9 = nums.into_iter().filter(|&amp;n| n &gt; min).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(vec![10, 15, 18, 13], greater_than_9); // ✅
}

</code></pre></pre>
<p><code>FnMut</code>要求可变引用并且可以被多次调用，<code>Fn</code>只要求不可变引用并可以被多次调用，从这一点来讲，<code>Fn</code>细化了<code>FnMut</code>。<code>Fn</code>可以被用于任何可以使用<code>FnMut</code>的地方，当然也包括可以使用<code>FnOnce</code>的地方。</p>
<p>如果一个闭包不从环境中捕获任何变量，从技术角度来讲它算不上是闭包，而只是一个被匿名声明的内联函数，并且可以作为一个普通函数指针（即<code>Fn</code>）被使用和传递，这包括可以使用<code>FnMut</code>和<code>FnOnce</code>的地方。</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn main() {
    let mut fn_ptr: fn(i32) -&gt; i32 = add_one;
    assert_eq!(fn_ptr(1), 2); // ✅

    // capture-less closure cast to fn pointer
    fn_ptr = |x| x + 1; // same as add_one
    assert_eq!(fn_ptr(1), 2); // ✅
}

</code></pre></pre>
<p>下面是一个传递普通函数指针而不是闭包的示例：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![-1, 1, -2, 2, -3, 3];
    let absolutes: Vec&lt;i32&gt; = nums.into_iter().map(i32::abs).collect();
    assert_eq!(vec![1, 1, 2, 2, 3, 3], absolutes); // ✅
}

</code></pre></pre>
<h3><a class="header" href="#其他-trait-other-traits" id="其他-trait-other-traits">其他 Trait （Other Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Deref</code></td><td>其他</td><td><code>*</code></td><td>不可变解引用</td></tr>
<tr><td><code>DerefMut</code></td><td>其他</td><td><code>*</code></td><td>可变解引用</td></tr>
<tr><td><code>Drop</code></td><td>其他</td><td>-</td><td>类型析构</td></tr>
<tr><td><code>Index</code></td><td>其他</td><td><code>[]</code></td><td>不可变索引</td></tr>
<tr><td><code>IndexMut</code></td><td>其他</td><td><code>[]</code></td><td>可变索引</td></tr>
<tr><td><code>RangeBounds</code></td><td>其他</td><td><code>..</code></td><td>区间</td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Deref&lt;Target = T&gt;</code>类型可以使用<code>*</code>操作符解引用为<code>T</code>类型。这在像<code>Box</code>和<code>Rc</code>这样的智能指针类型中有很明显的用例。尽管如此，但是我们在 Rust 代码中很少见到这种显式的解引用操作，这是因为 Rust 有一个被称为<code>解引用强制转换（deref coercion）</code>的特性。</p>
<p>当类型被作为函数参数传递、从函数返回或者作为方法调用的一部分时，Rust 会自动对这些类型进行解引用。这也解释了为什么我们可以在一个期望<code>&amp;str</code>和<code>&amp;[T]</code>的函数中可以传入<code>&amp;String</code>和<code>&amp;Vec&lt;T&gt;</code>，因为<code>String</code>实现了<code>Deref&lt;Target = str&gt;</code>并且<code>Vec&lt;T&gt;</code>实现了<code>Deref&lt;Target = [T]&gt;</code>。</p>
<p><code>Deref</code>和<code>DerefMut</code>应该仅被实现于智能指针类型。人们误用和滥用这些 trait 的最常见的方式是，试图把 OOP（面向对象程序设计）风格的数据继承塞进 Rust 中。这样是行不通的。Rust 不是 OOP。让我们进行一些测试，来看看它是在哪里、怎么样以及为什么行不通。让我们从下面的例子开始：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

struct Human {
    health_points: u32,
}

enum Weapon {
    Spear,
    Axe,
    Sword,
}

// a Soldier is just a Human with a Weapon
struct Soldier {
    human: Human,
    weapon: Weapon,
}

impl Deref for Soldier {
    type Target = Human;
    fn deref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Mount {
    Horse,
    Donkey,
    Cow,
}

// a Knight is just a Soldier with a Mount
struct Knight {
    soldier: Soldier,
    mount: Mount,
}

impl Deref for Knight {
    type Target = Soldier;
    fn deref(&amp;self) -&gt; &amp;Soldier {
        &amp;self.soldier
    }
}

enum Spell {
    MagicMissile,
    FireBolt,
    ThornWhip,
}

// a Mage is just a Human who can cast Spells
struct Mage {
    human: Human,
    spells: Vec&lt;Spell&gt;,
}

impl Deref for Mage {
    type Target = Human;
    fn deref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Staff {
    Wooden,
    Metallic,
    Plastic,
}

// a Wizard is just a Mage with a Staff
struct Wizard {
    mage: Mage,
    staff: Staff,
}

impl Deref for Wizard {
    type Target = Mage;
    fn deref(&amp;self) -&gt; &amp;Mage {
        &amp;self.mage
    }
}

fn borrows_human(human: &amp;Human) {}
fn borrows_soldier(soldier: &amp;Soldier) {}
fn borrows_knight(knight: &amp;Knight) {}
fn borrows_mage(mage: &amp;Mage) {}
fn borrows_wizard(wizard: &amp;Wizard) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types can be used as Humans
    borrows_human(&amp;human);
    borrows_human(&amp;soldier);
    borrows_human(&amp;knight);
    borrows_human(&amp;mage);
    borrows_human(&amp;wizard);
    // Knights can be used as Soldiers
    borrows_soldier(&amp;soldier);
    borrows_soldier(&amp;knight);
    // Wizards can be used as Mages
    borrows_mage(&amp;mage);
    borrows_mage(&amp;wizard);
    // Knights &amp; Wizards passed as themselves
    borrows_knight(&amp;knight);
    borrows_wizard(&amp;wizard);
}

<span class="boring">}
</span></code></pre></pre>
<p>乍看之下，上面的代码似乎还不错！但是，仔细观察之后它就没这么好了。首先，解引用强制转换仅作用于引用，因此，当我们想要传递所有权的时候它是行不通的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_human(human: Human) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types CANNOT be used as Humans
    takes_human(human);
    takes_human(soldier); // ❌
    takes_human(knight); // ❌
    takes_human(mage); // ❌
    takes_human(wizard); // ❌
}

<span class="boring">}
</span></code></pre></pre>
<p>此外，解引用强制转换在泛型上下文中是无法工作的。假定我们仅在 humans 上实现某个 trait：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Rest {
    fn rest(&amp;self);
}

impl Rest for Human {
    fn rest(&amp;self) {}
}

fn take_rest&lt;T: Rest&gt;(rester: &amp;T) {
    rester.rest()
}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types CANNOT be used as Rest types, only Human
    take_rest(&amp;human);
    take_rest(&amp;soldier); // ❌
    take_rest(&amp;knight); // ❌
    take_rest(&amp;mage); // ❌
    take_rest(&amp;wizard); // ❌
}

<span class="boring">}
</span></code></pre></pre>
<p>而且，尽管解引用强制转换在很多场景都可以使用，但它不是万能的。它无法作用于操作数，尽管操作符只是方法调用的语法糖。假定，我们想要<code>Mage（魔术师）</code>通过<code>+=</code>操作符学会<code>Spell（拼写）</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DerefMut for Wizard {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Mage {
        &amp;mut self.mage
    }
}

impl AddAssign&lt;Spell&gt; for Mage {
    fn add_assign(&amp;mut self, spell: Spell) {
        self.spells.push(spell);
    }
}

fn example(mut mage: Mage, mut wizard: Wizard, spell: Spell) {
    mage += spell;
    wizard += spell; // ❌ wizard not coerced to mage here
    wizard.add_assign(spell); // oof, we have to call it like this 🤦
}

<span class="boring">}
</span></code></pre></pre>
<p>在具有 OOP 风格的数据继承的编程语言中，一个方法中的<code>self</code>的值总是等于调用这个方法的类型，但是在 Rust 中，<code>self</code>的值永远等于实现这个方法的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Human {
    profession: &amp;'static str,
    health_points: u32,
}

impl Human {
    // self will always be a Human here, even if we call it on a Soldier
    fn state_profession(&amp;self) {
        println!(&quot;I'm a {}!&quot;, self.profession);
    }
}

struct Soldier {
    profession: &amp;'static str,
    human: Human,
    weapon: Weapon,
}

fn example(soldier: &amp;Soldier) {
    assert_eq!(&quot;servant&quot;, soldier.human.profession);
    assert_eq!(&quot;spearman&quot;, soldier.profession);
    soldier.human.state_profession(); // prints &quot;I'm a servant!&quot;
    soldier.state_profession(); // still prints &quot;I'm a servant!&quot; 🤦
}

<span class="boring">}
</span></code></pre></pre>
<p>当在一个新类型上实现<code>Deref</code>或<code>DerefMut</code>时，上面的陷阱令人震惊。假定我们想要创建一个<code>SortedVec</code>类型，它就是一个<code>Vec</code>只不过是有序的。下面是我们可能的实现方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SortedVec&lt;T: Ord&gt;(Vec&lt;T&gt;);

impl&lt;T: Ord&gt; SortedVec&lt;T&gt; {
    fn new(mut vec: Vec&lt;T&gt;) -&gt; Self {
        vec.sort();
        SortedVec(vec)
    }
    fn push(&amp;mut self, t: T) {
        self.0.push(t);
        self.0.sort();
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>显然，这里我们不能实现<code>DerefMut&lt;Target = Vec&lt;T&gt;&gt;</code>，否则任何使用<code>SortedVec</code>的人都能轻易打破已排好的顺序。但是，实现<code>Deref&lt;Target = Vec&lt;T&gt;&gt;</code>就一定安全么？试试找出下面程序中的 bug:</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct SortedVec&lt;T: Ord&gt;(Vec&lt;T&gt;);

impl&lt;T: Ord&gt; SortedVec&lt;T&gt; {
    fn new(mut vec: Vec&lt;T&gt;) -&gt; Self {
        vec.sort();
        SortedVec(vec)
    }
    fn push(&amp;mut self, t: T) {
        self.0.push(t);
        self.0.sort();
    }
}

impl&lt;T: Ord&gt; Deref for SortedVec&lt;T&gt; {
    type Target = Vec&lt;T&gt;;
    fn deref(&amp;self) -&gt; &amp;Vec&lt;T&gt; {
        &amp;self.0
    }
}

fn main() {
    let sorted = SortedVec::new(vec![2, 8, 6, 3]);
    sorted.push(1);
    let sortedClone = sorted.clone();
    sortedClone.push(4);
}

</code></pre></pre>
<p>我们未曾给<code>SortedVec</code>实现<code>Clone</code>，所以当我们调用<code>.clone()</code>方法时，编译器使用解引用强制转换把它解析为<code>Vec</code>上的方法调用，所以它会返回一个<code>Vec</code>而不是一个<code>SortedVec</code>！</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sorted: SortedVec&lt;i32&gt; = SortedVec::new(vec![2, 8, 6, 3]);
    sorted.push(1); // still sorted

    // calling clone on SortedVec actually returns a Vec 🤦
    let sortedClone: Vec&lt;i32&gt; = sorted.clone();
    sortedClone.push(4); // sortedClone no longer sorted 💀
}

</code></pre></pre>
<p>不管怎样，上面的限制、约束或者陷阱都不是 Rust 的错，因为 Rust 从来都没有被设计成一门 OO（面向对象）的语言或者把支持 OOP（面向对象程序设计）模式放在首位。</p>
<p>本节的要点在于不要试图在<code>Deref</code>和<code>DerefMut</code>的实现耍小聪明。它们仅仅适用于智能指针类型，目前只能在标准库中实现，因为智能指针类型目前需要 unstable 的特性和编译器的魔法才能工作。如果我们想要类似于<code>Deref</code>和<code>DerefMut</code>的功能和行为，我们可以去了解一下后面会提到的<code>AsRef</code>和<code>AsMut</code>。</p>
<h3><a class="header" href="#index--indexmut" id="index--indexmut">Index &amp; IndexMut</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Index&lt;Idx: ?Sized&gt; {
    type Output: ?Sized;
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}

trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; where Idx: ?Sized {
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}

<span class="boring">}
</span></code></pre></pre>
<p>我们可以将<code>[]</code>索引到带有 T 值的<code>Index&lt;T, Output = U&gt;</code>类型，索引操作将返回<code>&amp;U</code>值。为了语法方便，编译器会自动在索引操作返回值的前面插入一个解引用操作符<code>*</code>：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
    // indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
    let vec = vec![1, 2, 3, 4, 5];
    let num_ref: &amp;i32 = vec[0]; // ❌ expected &amp;i32 found i32

    // above line actually desugars to
    let num_ref: &amp;i32 = *vec[0]; // ❌ expected &amp;i32 found i32

    // both of these alternatives work
    let num: i32 = vec[0]; // ✅
    let num_ref = &amp;vec[0]; // ✅
}

</code></pre></pre>
<p>为了展示我们自己如何实现<code>Index</code>，下面是一个有趣的示例，这个例子展示了我们如何使用一个新类型和<code>Index</code>trait 在<code>Vec</code>上实现环绕索引和非负索引：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

struct WrappingIndex&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T&gt; Index&lt;usize&gt; for WrappingIndex&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        &amp;self.0[index % self.0.len()]
    }
}

impl&lt;T&gt; Index&lt;i128&gt; for WrappingIndex&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: i128) -&gt; &amp;T {
        let self_len = self.0.len() as i128;
        let idx = (((index % self_len) + self_len) % self_len) as usize;
        &amp;self.0[idx]
    }
}

#[test] // ✅
fn indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[0_usize]);
    assert_eq!(2, wrapping_vec[1_usize]);
    assert_eq!(3, wrapping_vec[2_usize]);
}

#[test] // ✅
fn wrapping_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[3_usize]);
    assert_eq!(2, wrapping_vec[4_usize]);
    assert_eq!(3, wrapping_vec[5_usize]);
}

#[test] // ✅
fn neg_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[-3_i128]);
    assert_eq!(2, wrapping_vec[-2_i128]);
    assert_eq!(3, wrapping_vec[-1_i128]);
}

#[test] // ✅
fn wrapping_neg_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[-6_i128]);
    assert_eq!(2, wrapping_vec[-5_i128]);
    assert_eq!(3, wrapping_vec[-4_i128]);
}

<span class="boring">}
</span></code></pre></pre>
<p>这里没有要求<code>Idx</code>类型是数值类型或者是一个<code>Range</code>，它也可以是一个枚举！下面是一个使用篮球位置在一支球队里检索球员的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

enum BasketballPosition {
    PointGuard,
    ShootingGuard,
    Center,
    PowerForward,
    SmallForward,
}

struct BasketballPlayer {
    name: &amp;'static str,
    position: BasketballPosition,
}

struct BasketballTeam {
    point_guard: BasketballPlayer,
    shooting_guard: BasketballPlayer,
    center: BasketballPlayer,
    power_forward: BasketballPlayer,
    small_forward: BasketballPlayer,
}

impl Index&lt;BasketballPosition&gt; for BasketballTeam {
    type Output = BasketballPlayer;
    fn index(&amp;self, position: BasketballPosition) -&gt; &amp;BasketballPlayer {
        match position {
            BasketballPosition::PointGuard =&gt; &amp;self.point_guard,
            BasketballPosition::ShootingGuard =&gt; &amp;self.shooting_guard,
            BasketballPosition::Center =&gt; &amp;self.center,
            BasketballPosition::PowerForward =&gt; &amp;self.power_forward,
            BasketballPosition::SmallForward =&gt; &amp;self.small_forward,
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#drop" id="drop">Drop</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型实现了<code>Drop</code>，那么<code>drop</code>将会在该类型离开作用域但是销毁之前被调用。我们很少需要去为我们的类型实现它，但是如果一个类型中持有某些外部资源，这些资源需要在类型销毁时被清理，这种情况下就会用到了。</p>
<p>标准库中有一个<code>BufWriter</code>类型让我们能够把写入的数据缓冲到<code>Write</code>类型中。但是，如果<code>BufWriter</code>在它里面的内容被刷入到底层的<code>Write</code>类型之前就被销毁了，该怎么办呢？幸运的是那是不可能的！<code>BufWriter</code>实现了<code>Drop</code>trait，因此，无论什么它什么时候离开作用域，<code>flush</code>总会被调用！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; Drop for BufWriter&lt;W&gt; {
    fn drop(&amp;mut self) {
        self.flush_buf();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>此外，Rust 中的<code>Mutexs</code>没有<code>unlock()</code>方法，因为它们不需要！在<code>Mutex</code>上调用<code>lock()</code>会返回一个<code>MutexGuard</code>，当<code>MutexGuard</code>离开作用域时，它会自动解锁（unlock）<code>Mutex</code>，这要归功于它的<code>Drop</code>实现:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.inner.raw_unlock();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一般而言，如果你正在实现对某类资源的抽象，这类资源需要在使用后被清理，那就是时候充分利用<code>Drop</code> trait 了。</p>
<h2><a class="header" href="#转换-traitsconversion-traits" id="转换-traitsconversion-traits">转换 Traits（Conversion Traits）</a></h2>
<h3><a class="header" href="#from--into" id="from--into">From &amp; Into</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>From&lt;T&gt;</code>类型允许我们把<code>T</code>转换为<code>Self</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Into&lt;T&gt;</code>类型允许我们把<code>Self</code>转换为<code>T</code>。
它们就像是一个硬币的两面。我们只能为自己的类型实现<code>From&lt;T&gt;</code>，因为<code>Into&lt;T&gt;</code>的实现会通过 generic blanket impl 自动提供：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>这两个 trait 之所以存在，是因为它能够让我们以稍微不同的方式来进行 trait 约束（bound）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T&gt;(t: T)
where
    // these bounds are equivalent
    T: From&lt;i32&gt;,
    i32: Into&lt;T&gt;
{
    // these examples are equivalent
    let example: T = T::from(0);
    let example: T = 0.into();
}
<span class="boring">}
</span></code></pre></pre>
<p>没有规则强制要求什么时候使用前者或后者，所以在每种情景下采用最合理的方式就可以了。现在让我们来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;[i32; 2]&gt; for Point {
    fn from([x, y]: [i32; 2]) -&gt; Self {
        Point { x, y }
    }
}

fn example() {
    // 使用 From
    let origin = Point::from((0, 0));
    let origin = Point::from([0, 0]);

    // 使用 Into
    let origin: Point = (0, 0).into();
    let origin: Point = [0, 0].into();
}

<span class="boring">}
</span></code></pre></pre>
<p>这个实现不是对称的，因此，如果我们想要把<code>Point</code>转为 tuple 和 array，我们必须显式地添加下面的内容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;Point&gt; for (i32, i32) {
    fn from(Point { x, y }: Point) -&gt; Self {
        (x, y)
    }
}

impl From&lt;[i32; 2]&gt; for Point {
    fn from([x, y]: [i32; 2]) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;Point&gt; for [i32; 2] {
    fn from(Point { x, y }: Point) -&gt; Self {
        [x, y]
    }
}

fn example() {
    // 从 (i32, i32) 到 Point
    let point = Point::from((0, 0));
    let point: Point = (0, 0).into();

    // 从 Point 到 (i32, i32)
    let tuple = &lt;(i32, i32)&gt;::from(point);
    let tuple: (i32, i32) = point.into();

    // 从 [i32; 2] 到 Point
    let point = Point::from([0, 0]);
    let point: Point = [0, 0].into();

    // 从 Point 到 [i32; 2]
    let array = &lt;[i32; 2]&gt;::from(point);
    let array: [i32; 2] = point.into();
}

<span class="boring">}
</span></code></pre></pre>
<p><code>From&lt;T&gt;</code>的一个常见用法是精简模板代码。假定我们想要在程序中添加一个<code>Triangle</code>类型，它里面包含三个<code>Point</code>，下面是我们可以构造它的方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Point {
        Point { x, y }
    }
}

struct Triangle {
    p1: Point,
    p2: Point,
    p3: Point,
}

impl Triangle {
    fn new(p1: Point, p2: Point, p3: Point) -&gt; Triangle {
        Triangle { p1, p2, p3 }
    }
}

impl&lt;P&gt; From&lt;[P; 3]&gt; for Triangle
where
    P: Into&lt;Point&gt;
{
    fn from([p1, p2, p3]: [P; 3]) -&gt; Triangle {
        Triangle {
            p1: p1.into(),
            p2: p2.into(),
            p3: p3.into(),
        }
    }
}

fn example() {
    // 手动构造
    let triangle = Triangle {
        p1: Point {
            x: 0,
            y: 0,
        },
        p2: Point {
            x: 1,
            y: 1,
        },
        p3: Point {
            x: 2,
            y: 2,
        },
    };

    // 使用 Point::new
    let triangle = Triangle {
        p1: Point::new(0, 0),
        p2: Point::new(1, 1),
        p3: Point::new(2, 2),
    };

    // 使用 From&lt;(i32, i32)&gt; for Point
    let triangle = Triangle {
        p1: (0, 0).into(),
        p2: (1, 1).into(),
        p3: (2, 2).into(),
    };

    // 使用 Triangle::new + From&lt;(i32, i32)&gt; for Point
    let triangle = Triangle::new(
        (0, 0).into(),
        (1, 1).into(),
        (2, 2).into(),
    );

    // 使用 From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
    let triangle: Triangle = [
        (0, 0),
        (1, 1),
        (2, 2),
    ].into();
}

<span class="boring">}
</span></code></pre></pre>
<p>关于你应该什么时候，以什么方式、什么理由来为我们的类型实现<code>From&lt;T&gt;</code>，并没有强制规定，这取决于你对具体情况的判断。</p>
<p><code>Into&lt;T&gt;</code>一个常见的用途是，使得需要拥有值的函数具有通用性，而不必关心它们是拥有值还是借用值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}

impl Person {
    // 接受:
    // - String
    fn new1(name: String) -&gt; Person {
        Person { name }
    }

    // 接受:
    // - String
    // - &amp;String
    // - &amp;str
    // - Box&lt;str&gt;
    // - Cow&lt;'_, str&gt;
    // - char
    // 因为上面所有的类型都可以转换为 String
    fn new2&lt;N: Into&lt;String&gt;&gt;(name: N) -&gt; Person {
        Person { name: name.into() }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#错误处理error-handling" id="错误处理error-handling">错误处理（Error Handling）</a></h2>
<p>讨论错误处理和<code>Error</code> trait 的最好时机应该是紧跟在<code>Display</code>、<code>Debug</code>、<code>Any</code>、<code>From</code>之后，但是在<code>TryFrom</code>之前，这也是为什么把错误处理部分尴尬地嵌入在转换 trait 之间。</p>
<h3><a class="header" href="#error" id="error">Error</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Error: Debug + Display {
    // 提供默认实现
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;;
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt;;
    fn description(&amp;self) -&gt; &amp;str;
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，错误（error）是被返回（return）的，而不是被抛出（throw）的，让我们看个例子。</p>
<p>因为整数除以 0 会 panic，如果我们想要让我们的程序更为安全，我们可以实现一个<code>safe_div</code>函数，它会返回一个<code>Result</code>，就像下面这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::error;

#[derive(Debug, PartialEq)]
struct DivByZero;

impl fmt::Display for DivByZero {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;division by zero error&quot;)
    }
}

impl error::Error for DivByZero {}

fn safe_div(numerator: i32, denominator: i32) -&gt; Result&lt;i32, DivByZero&gt; {
    if denominator == 0 {
        return Err(DivByZero);
    }
    Ok(numerator / denominator)
}

#[test] // ✅
fn test_safe_div() {
    assert_eq!(safe_div(8, 2), Ok(4));
    assert_eq!(safe_div(5, 0), Err(DivByZero));
}

<span class="boring">}
</span></code></pre></pre>
<p>因为错误是被返回而不是被抛出，所以这些错误必须被显式地处理，如果当前函数无法处理错误，该函数应该把错误传递给自己的调用者。传递错误的最常用方式是使用<code>?</code>操作符，它是现在已经弃用的<code>try!</code>宏的语法糖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! try {
    ($expr:expr) =&gt; {
        match $expr {
            // if Ok just unwrap the value
            Ok(val) =&gt; val,
            // if Err map the err value using From and return
            Err(err) =&gt; {
                return Err(From::from(err));
            }
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们想要写一个函数，该函数读取文件内容到<code>String</code>里，我们可以像这样写：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Read;
use std::path::Path;
use std::io;
use std::fs::File;

fn read_file_to_string(path: &amp;Path) -&gt; Result&lt;String, io::Error&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error
    Ok(contents)
}
<span class="boring">}
</span></code></pre></pre>
<p>假定我们当前正在读取的文件内容是一串数字，并且我们想要把这些数字求和，我们可能会把函数更新成这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Read;
use std::path::Path;
use std::io;
use std::fs::File;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, /*这里放置什么? */&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>但是，现在我们的<code>Result</code>里的错误类型应该是什么？它要么返回一个<code>io::Error</code>，要么返回一个<code>ParseIntError</code>。我们尝试寻找第三种方式来解决这个问题，以最快最乱的方式开始，以最健壮的方式结束。</p>
<p>第一种方式就是，识别出所有实现了<code>Error</code>和<code>Display</code>的类型，这样我们把所有的错误映射（map）到<code>String</code>类型并把<code>String</code>作为我们的错误类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;
use std::path::Path;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, String&gt; {
    let mut file = File::open(path)
        .map_err(|e| e.to_string())?; // ⬆️ io::Error -&gt; String
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)
        .map_err(|e| e.to_string())?; // ⬆️ io::Error -&gt; String
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()
            .map_err(|e| e.to_string())?; // ⬆️ ParseIntError -&gt; String
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>但是，这种方式的缺点在于，我们会丢弃所有的错误类型信息，从而导致调用者在处理错误时十分困难。</p>
<p>另外一个不太明显的优点则是，我们可以定制字符串来提供更多的特定上下文信息。例如，<code>ParseIntError</code>通常会变成字符串<code>“invalid digit found in string”</code>，这个信息就非常模糊并且没有提及无效的字符串是什么或者它正在尝试解析到哪一类整数类型。如果我们正在调试这个问题，这个错误信息几乎没什么用。尽管如此，我们还可以自己动手提供所有的上下文信息来改善这个问题：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sum += line.parse::&lt;i32&gt;()
    .map_err(|_| format!(&quot;failed to parse {} into i32&quot;, line))?;

<span class="boring">}
</span></code></pre></pre>
<p>第二种方式则是充分利用标准库中的 generic blanket impl：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;E: error::Error&gt; From&lt;E&gt; for Box&lt;dyn error::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这意味着，任意的<code>Error</code>类型都可以通过<code>?</code>被隐式地转换为<code>Box&lt;dyn error::Error&gt;</code>，因此我们可以把任何可能产生错误的函数返回的<code>Result</code>中的错误类型设置为<code>Box&lt;dyn error::Error&gt;</code>，这样<code>?</code>操作符就可以帮我们完成剩下的工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::error;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, Box&lt;dyn error::Error&gt;&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
    }
    Ok(sum)
}

<span class="boring">}
</span></code></pre></pre>
<p>虽然更为简洁，但是它似乎也存在着前面一种方式的缺点，即丢掉了类型信息。大多数情况下的确如此，但是如果调用者知道函数的实现细节，它们仍然可以通过使用<code>error::Error</code>上的<code>downcast_ref()</code>方法来处理不同的错误类型，这与它在<code>dyn Any</code>类型上的作用相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_sum_file_errors(path: &amp;Path) {
    match sum_file(path) {
        Ok(sum) =&gt; println!(&quot;the sum is {}&quot;, sum),
        Err(err) =&gt; {
            if let Some(e) = err.downcast_ref::&lt;io::Error&gt;() {
                // 处理 io::Error
            } else if let Some(e) = err.downcast_ref::&lt;ParseIntError&gt;() {
                // 处理 ParseIntError
            } else {
                // 我们知道 sum_file 只会返回上面错误中的其中一个
                // 所以不会到达这个分支
                unreachable!();
            }
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>第三种方法是最稳健和类型安全的方法，它可以汇总这些不同的错误，使用一个枚举类型构建我们自己的自定义错误类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::ParseIntError;
use std::fs::File;
use std::io;
use std::io::Read;
use std::path::Path;
use std::error;
use std::fmt;

#[derive(Debug)]
enum SumFileError {
    Io(io::Error),
    Parse(ParseIntError),
}

impl From&lt;io::Error&gt; for SumFileError {
    fn from(err: io::Error) -&gt; Self {
        SumFileError::Io(err)
    }
}

impl From&lt;ParseIntError&gt; for SumFileError {
    fn from(err: ParseIntError) -&gt; Self {
        SumFileError::Parse(err)
    }
}

impl fmt::Display for SumFileError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            SumFileError::Io(err) =&gt; write!(f, &quot;sum file error: {}&quot;, err),
            SumFileError::Parse(err) =&gt; write!(f, &quot;sum file error: {}&quot;, err),
        }
    }
}

impl error::Error for SumFileError {
    // 这个方法的默认实现总是返回 None
    //但是我们现在重写它，让它更有用    
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        Some(match self {
            SumFileError::Io(err) =&gt; err,
            SumFileError::Parse(err) =&gt; err,
        })
    }
}

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, SumFileError&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error -&gt; SumFileError
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error -&gt; SumFileError
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError -&gt; SumFileError
    }
    Ok(sum)
}

fn handle_sum_file_errors(path: &amp;Path) {
    match sum_file(path) {
        Ok(sum) =&gt; println!(&quot;the sum is {}&quot;, sum),
        Err(SumFileError::Io(err)) =&gt; {
            // 处理 io::Error
        },
        Err(SumFileError::Parse(err)) =&gt; {
            // 处理 ParseIntError
        },
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#继续转换类型conversion-traits-continued" id="继续转换类型conversion-traits-continued">继续转换类型（Conversion Traits Continued）</a></h2>
<h3><a class="header" href="#tryfrom--tryinto" id="tryfrom--tryinto">TryFrom &amp; TryInto</a></h3>
<p><code>TryFrom</code>和<code>TryInto</code>是<code>From</code>和<code>Into</code>的可能会失败的版本。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TryFrom&lt;T&gt; {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

trait TryInto&lt;T&gt; {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p>类似于<code>Into</code>，我们无法实现<code>TryInto</code>，因为它的实现是由 generic blanket impl提供：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,
{
    type Error = U::Error;

    fn try_into(self) -&gt; Result&lt;U, U::Error&gt; {
        U::try_from(self)
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>假定在我们的程序上下文环境中，<code>Point</code>中的<code>x</code>和<code>y</code>如果值小于<code>-1000</code>或者大于<code>1000</code>没有意义。下面是我们使用<code>TryFrom</code>重写之前的<code>From</code>实现来告诉用户，现在这种转换可以失败。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;
use std::error;
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

#[derive(Debug)]
struct OutOfBounds;

impl fmt::Display for OutOfBounds {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;out of bounds&quot;)
    }
}

impl error::Error for OutOfBounds {}

// 现在是可以出错的
impl TryFrom&lt;(i32, i32)&gt; for Point {
    type Error = OutOfBounds;
    fn try_from((x, y): (i32, i32)) -&gt; Result&lt;Point, OutOfBounds&gt; {
        if x.abs() &gt; 1000 || y.abs() &gt; 1000 {
            return Err(OutOfBounds);
        }
        Ok(Point { x, y })
    }
}

// 仍然是不会出错的
impl From&lt;Point&gt; for (i32, i32) {
    fn from(Point { x, y }: Point) -&gt; Self {
        (x, y)
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>下面是对<code>Triangle</code>的<code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code>实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::{TryFrom, TryInto};
use std::error;
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

#[derive(Debug)]
struct OutOfBounds;

impl fmt::Display for OutOfBounds {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;out of bounds&quot;)
    }
}

impl error::Error for OutOfBounds {}

impl TryFrom&lt;(i32, i32)&gt; for Point {
    type Error = OutOfBounds;
    fn try_from((x, y): (i32, i32)) -&gt; Result&lt;Self, Self::Error&gt; {
        if x.abs() &gt; 1000 || y.abs() &gt; 1000 {
            return Err(OutOfBounds);
        }
        Ok(Point { x, y })
    }
}

struct Triangle {
    p1: Point,
    p2: Point,
    p3: Point,
}

impl&lt;P&gt; TryFrom&lt;[P; 3]&gt; for Triangle
where
    P: TryInto&lt;Point&gt;,
{
    type Error = P::Error;
    fn try_from([p1, p2, p3]: [P; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Triangle {
            p1: p1.try_into()?,
            p2: p2.try_into()?,
            p3: p3.try_into()?,
        })
    }
}

fn example() -&gt; Result&lt;Triangle, OutOfBounds&gt; {
    let t: Triangle = [(0, 0), (1, 1), (2, 2)].try_into()?;
    Ok(t)
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fromstr" id="fromstr">FromStr</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>FromStr</code> 类型允许执行一个从<code>&amp;str</code>到<code>Self</code>的可失败的转换。最常见的使用是在<code>&amp;str</code>上调用<code>.parse()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;

fn example&lt;T: FromStr&gt;(s: &amp;'static str) {
    // 这些都是相等的
    let t: Result&lt;T, _&gt; = FromStr::from_str(s);
    let t = T::from_str(s);
    let t: Result&lt;T, _&gt; = s.parse();
    let t = s.parse::&lt;T&gt;(); // 最常见的
}
<span class="boring">}
</span></code></pre></pre>
<p>例如，在<code>Point</code>上的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error;
use std::fmt;
use std::iter::Enumerate;
use std::num::ParseIntError;
use std::str::{Chars, FromStr};

#[derive(Debug, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Self {
        Point { x, y }
    }
}

#[derive(Debug, PartialEq)]
struct ParsePointError;

impl fmt::Display for ParsePointError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;failed to parse point&quot;)
    }
}

impl From&lt;ParseIntError&gt; for ParsePointError {
    fn from(_e: ParseIntError) -&gt; Self {
        ParsePointError
    }
}

impl error::Error for ParsePointError {}

impl FromStr for Point {
    type Err = ParsePointError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let is_num = |(_, c): &amp;(usize, char)| matches!(c, '0'..='9' | '-');
        let isnt_num = |t: &amp;(_, _)| !is_num(t);

        let get_num =
            |char_idxs: &amp;mut Enumerate&lt;Chars&lt;'_&gt;&gt;| -&gt; Result&lt;(usize, usize), ParsePointError&gt; {
                let (start, _) = char_idxs
                    .skip_while(isnt_num)
                    .next()
                    .ok_or(ParsePointError)?;
                let (end, _) = char_idxs
                    .skip_while(is_num)
                    .next()
                    .ok_or(ParsePointError)?;
                Ok((start, end))
            };

        let mut char_idxs = s.chars().enumerate();
        let (x_start, x_end) = get_num(&amp;mut char_idxs)?;
        let (y_start, y_end) = get_num(&amp;mut char_idxs)?;

        let x = s[x_start..x_end].parse::&lt;i32&gt;()?;
        let y = s[y_start..y_end].parse::&lt;i32&gt;()?;

        Ok(Point { x, y })
    }
}

#[test] // ✅
fn pos_x_y() {
    let p = &quot;(4, 5)&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Ok(Point::new(4, 5)));
}

#[test] // ✅
fn neg_x_y() {
    let p = &quot;(-6, -2)&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Ok(Point::new(-6, -2)));
}

#[test] // ✅
fn not_a_point() {
    let p = &quot;not a point&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Err(ParsePointError));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>FromStr</code>和<code>TryFrom&lt;&amp;str&gt;</code>有着相同的签名。只要我们通过其中一个实现另一个，先实现哪个并不重要。下面是对<code>Point</code>实现<code>TryFrom&lt;&amp;str&gt;</code>，假定它已经实现了<code>FromStr</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TryFrom&lt;&amp;str&gt; for Point {
    type Error = &lt;Point as FromStr&gt;::Err;
    fn try_from(s: &amp;str) -&gt; Result&lt;Point, Self::Error&gt; {
        &lt;Point as FromStr&gt;::from_str(s)
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#asref--asmut" id="asref--asmut">AsRef &amp; AsMut</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsRef&lt;T: ?Sized&gt; {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

trait AsMut&lt;T: ?Sized&gt; {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef</code>被用于轻量级的引用到引用之间的转换。然而，它最常见的一个用途是使函数在是否获取所有权上具有通用性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 接受:
//  - &amp;str
//  - &amp;String
fn takes_str(s: &amp;str) {
    // use &amp;str
}

// 接受:
//  - &amp;str
//  - &amp;String
//  - String
fn takes_asref_str&lt;S: AsRef&lt;str&gt;&gt;(s: S) {
    let s: &amp;str = s.as_ref();
    // 使用 &amp;str
}

fn example(slice: &amp;str, borrow: &amp;String, owned: String) {
    takes_str(slice);
    takes_str(borrow);
    takes_str(owned); // ❌
    takes_asref_str(slice);
    takes_asref_str(borrow);
    takes_asref_str(owned); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<p>另一个常见用途是返回一个内部私有数据的引用，该数据由一个保护不变性的类型所包裹。标准库中一个比较好的示例是<code>String</code>，它包裹了<code>Vec&lt;u8&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>内部的<code>Vec&lt;u8&gt;</code>不能被公开，因为如果这样的话，人们就会修改里面的字节并破坏<code>String</code>中有效的 UTF-8 编码。但是，暴露内部字节数组的一个不可变的只读引用是安全的，即下面的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AsRef&lt;[u8]&gt; for String;
<span class="boring">}
</span></code></pre></pre>
<p>一般而言，只有当一个类型包裹了其他类型用来为该内部类型提供了额外功能或者保护内部类型的不变性时，为这样的类型实现<code>AsRef</code>才有意义。
让我们来看一个<code>AsRef</code>的不合适使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    age: u32,
}

impl AsRef&lt;String&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

impl AsRef&lt;u32&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;u32 {
        &amp;self.age
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>一开始是可行的，而且看上去还有点道理，但是当我们为<code>User</code>添加更多成员时，问题就出现了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    email: String,
    age: u32,
    height: u32,
}

impl AsRef&lt;String&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;String {、
        //我们返回 name 还是 email?        
    }
}

impl AsRef&lt;u32&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;u32 {
        //我们返回 age 还是 height？
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><code>User</code>是由<code>String</code>和<code>u32</code>组成，但是它并不等同于一个<code>String</code>和一个<code>u32</code>，甚至我们还会有更多的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: Name,
    email: Email,
    age: Age,
    height: Height,
}
<span class="boring">}
</span></code></pre></pre>
<p>对于这样的类型实现<code>AsRef</code>没有什么意义，因为<code>AsRef</code>用于语义相等的事物之间引用到引用的转换，而且<code>Name</code>、<code>Email</code>、<code>Age</code>以及<code>Height</code>并不等同于一个<code>User</code>。</p>
<p>下面是一个好的示例，其中，我们会引入一个新类型<code>Moderator</code>，它只包裹了一个<code>User</code>并添加了特定的审核权限：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    age: u32,
}

//不幸地是，标准库并没有提供一个generic blanket impl来避免这种重复的实现
impl AsRef&lt;User&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;User {
        self
    }
}

enum Privilege {
    BanUsers,
    EditPosts,
    DeletePosts,
}

//尽管 Moderators 有一些特殊权限，它们仍然是普通的 User 
//并且应该做相同的事情
struct Moderator {
    user: User,
    privileges: Vec&lt;Privilege&gt;
}

impl AsRef&lt;Moderator&gt; for Moderator {
    fn as_ref(&amp;self) -&gt; &amp;Moderator {
        self
    }
}

impl AsRef&lt;User&gt; for Moderator {
    fn as_ref(&amp;self) -&gt; &amp;User {
        &amp;self.user
    }
}

//使用 User 和 Moderators （也是一种User）应该都是可以调用的
fn create_post&lt;U: AsRef&lt;User&gt;&gt;(u: U) {
    let user = u.as_ref();
    // etc
}

fn example(user: User, moderator: Moderator) {
    create_post(&amp;user);
    create_post(&amp;moderator); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<p>这是有效的，因为<code>Moderator</code>就是<code>User</code>。下面是<code>Deref</code>章节中的例子，我们用了<code>AsRef</code>来实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::AsRef;

struct Human {
    health_points: u32,
}

impl AsRef&lt;Human&gt; for Human {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        self
    }
}

enum Weapon {
    Spear,
    Axe,
    Sword,
}

// a Soldier is just a Human with a Weapon
struct Soldier {
    human: Human,
    weapon: Weapon,
}

impl AsRef&lt;Soldier&gt; for Soldier {
    fn as_ref(&amp;self) -&gt; &amp;Soldier {
        self
    }
}

impl AsRef&lt;Human&gt; for Soldier {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Mount {
    Horse,
    Donkey,
    Cow,
}

// a Knight is just a Soldier with a Mount
struct Knight {
    soldier: Soldier,
    mount: Mount,
}

impl AsRef&lt;Knight&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Knight {
        self
    }
}

impl AsRef&lt;Soldier&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Soldier {
        &amp;self.soldier
    }
}

impl AsRef&lt;Human&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.soldier.human
    }
}

enum Spell {
    MagicMissile,
    FireBolt,
    ThornWhip,
}

// a Mage is just a Human who can cast Spells
struct Mage {
    human: Human,
    spells: Vec&lt;Spell&gt;,
}

impl AsRef&lt;Mage&gt; for Mage {
    fn as_ref(&amp;self) -&gt; &amp;Mage {
        self
    }
}

impl AsRef&lt;Human&gt; for Mage {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Staff {
    Wooden,
    Metallic,
    Plastic,
}

// a Wizard is just a Mage with a Staff
struct Wizard {
    mage: Mage,
    staff: Staff,
}

impl AsRef&lt;Wizard&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Wizard {
        self
    }
}

impl AsRef&lt;Mage&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Mage {
        &amp;self.mage
    }
}

impl AsRef&lt;Human&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.mage.human
    }
}

fn borrows_human&lt;H: AsRef&lt;Human&gt;&gt;(human: H) {}
fn borrows_soldier&lt;S: AsRef&lt;Soldier&gt;&gt;(soldier: S) {}
fn borrows_knight&lt;K: AsRef&lt;Knight&gt;&gt;(knight: K) {}
fn borrows_mage&lt;M: AsRef&lt;Mage&gt;&gt;(mage: M) {}
fn borrows_wizard&lt;W: AsRef&lt;Wizard&gt;&gt;(wizard: W) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types can be used as Humans
    borrows_human(&amp;human);
    borrows_human(&amp;soldier);
    borrows_human(&amp;knight);
    borrows_human(&amp;mage);
    borrows_human(&amp;wizard);
    // Knights can be used as Soldiers
    borrows_soldier(&amp;soldier);
    borrows_soldier(&amp;knight);
    // Wizards can be used as Mages
    borrows_mage(&amp;mage);
    borrows_mage(&amp;wizard);
    // Knights &amp; Wizards passed as themselves
    borrows_knight(&amp;knight);
    borrows_wizard(&amp;wizard);
}

<span class="boring">}
</span></code></pre></pre>
<p><code>Deref</code>在之前的例子中没有起作用，是因为解引用强制转换是类型间的隐式转换，这就为人们制定错误的想法并对其行为方式的期望留下了空间。<code>AsRef</code>能够工作是因为它让类型之间的转换变为显式的，并且没有给开发者错误的想法和期望留有余地。</p>
<h3><a class="header" href="#borrow--borrowmut" id="borrow--borrowmut">Borrow &amp; BorrowMut</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Borrow&lt;Borrowed&gt;
where
    Borrowed: ?Sized,
{
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}

trait BorrowMut&lt;Borrowed&gt;: Borrow&lt;Borrowed&gt;
where
    Borrowed: ?Sized,
{
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed;
}

<span class="boring">}
</span></code></pre></pre>
<p>这些 trait 被发明用于解决非常具体的问题，即使用<code>&amp;str</code>类型的值在<code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code>和<code>BTreeMap</code>中查找<code>String</code>类型的 key。</p>
<p>我们可以把<code>Borrow&lt;T&gt;</code>和<code>BorrowMut&lt;T&gt;</code>看作更严格的<code>AsRef&lt;T&gt;</code>和<code>AsMut&lt;T&gt;</code>，它们返回的引用<code>&amp;T</code>与<code>Self</code>有等价性的<code>Eq</code>、<code>Hash</code>和<code>Ord</code>实现。通过下面的例子会更易于理解：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::Borrow;
use std::hash::Hasher;
use std::collections::hash_map::DefaultHasher;
use std::hash::Hash;

fn get_hash&lt;T: Hash&gt;(t: T) -&gt; u64 {
    let mut hasher = DefaultHasher::new();
    t.hash(&amp;mut hasher);
    hasher.finish()
}

fn asref_example&lt;Owned, Ref&gt;(owned1: Owned, owned2: Owned)
where
    Owned: Eq + Ord + Hash + AsRef&lt;Ref&gt;,
    Ref: Eq + Ord + Hash
{
    let ref1: &amp;Ref = owned1.as_ref();
    let ref2: &amp;Ref = owned2.as_ref();

    // refs aren't required to be equal if owned types are equal
    assert_eq!(owned1 == owned2, ref1 == ref2); // ❌

    let owned1_hash = get_hash(&amp;owned1);
    let owned2_hash = get_hash(&amp;owned2);
    let ref1_hash = get_hash(&amp;ref1);
    let ref2_hash = get_hash(&amp;ref2);

    // ref hashes aren't required to be equal if owned type hashes are equal
    assert_eq!(owned1_hash == owned2_hash, ref1_hash == ref2_hash); // ❌

    // ref comparisons aren't required to match owned type comparisons
    assert_eq!(owned1.cmp(&amp;owned2), ref1.cmp(&amp;ref2)); // ❌
}

fn borrow_example&lt;Owned, Borrowed&gt;(owned1: Owned, owned2: Owned)
where
    Owned: Eq + Ord + Hash + Borrow&lt;Borrowed&gt;,
    Borrowed: Eq + Ord + Hash
{
    let borrow1: &amp;Borrowed = owned1.borrow();
    let borrow2: &amp;Borrowed = owned2.borrow();

    // borrows are required to be equal if owned types are equal
    assert_eq!(owned1 == owned2, borrow1 == borrow2); // ✅

    let owned1_hash = get_hash(&amp;owned1);
    let owned2_hash = get_hash(&amp;owned2);
    let borrow1_hash = get_hash(&amp;borrow1);
    let borrow2_hash = get_hash(&amp;borrow2);

    // borrow hashes are required to be equal if owned type hashes are equal
    assert_eq!(owned1_hash == owned2_hash, borrow1_hash == borrow2_hash); // ✅

    // borrow comparisons are required to match owned type comparisons
    assert_eq!(owned1.cmp(&amp;owned2), borrow1.cmp(&amp;borrow2)); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<p>意识到这些 trait 以及它们为什么存在是有益的，因为它有助于搞清楚<code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code>以及<code>BTreeMap</code>的某些方法，但是我们很少需要为我们的类型实现这些 trait，因为我们很少需要创建一对儿类型，其中一个是另一个的借用版本。如果我们有某个类型<code>T</code>，<code>&amp;T</code>在 99.99%的情况下可以完成工作，并且因为 generic blanket impl，<code>T:Borrorw&lt;T&gt;</code>已经为所有的类型<code>T</code>实现了，所以我们不需要手动地实现它并且我们不需要创建一个<code>U</code>以用来<code>T:Borrow&lt;U&gt;</code>。</p>
<h3><a class="header" href="#toowned" id="toowned">ToOwned</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    fn to_owned(&amp;self) -&gt; Self::Owned;

    // 提供默认实现
    fn clone_into(&amp;self, target: &amp;mut Self::Owned);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ToOwned</code>是<code>Clone</code>的一个更为通用的版本。<code>Clone</code>允许我们获取一个<code>&amp;T</code>并把它转为一个<code>T</code>，但是<code>ToOwned</code>允许我们拿到一个<code>&amp;Borrowed</code>并把它转为一个<code>Owned</code>，其中<code>Owned: Borrow&lt;Borrowed&gt;</code>。</p>
<p>换句话说，我们不能从一个<code>&amp;str</code>克隆一个<code>String</code>，或者从一个<code>&amp;Path</code>克隆一个<code>PathBuf</code>，或者从一个<code>&amp;OsStr</code>克隆一个<code>OsString</code>，因为<code>clone</code>方法签名不支持这种跨类型的克隆，这就是<code>ToOwned</code>产生的原因。</p>
<p>类似于<code>Borrow</code>和<code>BorrowMut</code>，知道这个 trait 并理解它什么存在同样是有益的，只是我们几乎不需要为我们的类型实现它。</p>
<h2><a class="header" href="#iteration-traits" id="iteration-traits">Iteration Traits</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // provided default impls
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
    fn count(self) -&gt; usize;
    fn last(self) -&gt; Option&lt;Self::Item&gt;;
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt;;
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;;
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;;
    fn chain&lt;U&gt;(
        self, 
        other: U
    ) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator&lt;Item = Self::Item&gt;;
    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator;
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; B;
    fn for_each&lt;F&gt;(self, f: F)
    where
        F: FnMut(Self::Item);
    fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt;;
    fn peekable(self) -&gt; Peekable&lt;Self&gt;;
    fn skip_while&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn map_while&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt;
    where
        P: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn skip(self, n: usize) -&gt; Skip&lt;Self&gt;;
    fn take(self, n: usize) -&gt; Take&lt;Self&gt;;
    fn scan&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt;
    where
        F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;;
    fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;
    where
        F: FnMut(Self::Item) -&gt; U,
        U: IntoIterator;
    fn flatten(self) -&gt; Flatten&lt;Self&gt;
    where
        Self::Item: IntoIterator;
    fn fuse(self) -&gt; Fuse&lt;Self&gt;;
    fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt;
    where
        F: FnMut(&amp;Self::Item);
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self;
    fn collect&lt;B&gt;(self) -&gt; B
    where
        B: FromIterator&lt;Self::Item&gt;;
    fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)
    where
        F: FnMut(&amp;Self::Item) -&gt; bool,
        B: Default + Extend&lt;Self::Item&gt;;
    fn partition_in_place&lt;'a, T, P&gt;(self, predicate: P) -&gt; usize
    where
        Self: DoubleEndedIterator&lt;Item = &amp;'a mut T&gt;,
        T: 'a,
        P: FnMut(&amp;T) -&gt; bool;
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R
    where
        F: FnMut(B, Self::Item) -&gt; R,
        R: Try&lt;Ok = B&gt;;
    fn try_for_each&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R
    where
        F: FnMut(Self::Item) -&gt; R,
        R: Try&lt;Ok = ()&gt;;
    fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, Self::Item) -&gt; B;
    fn fold_first&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(Self::Item, Self::Item) -&gt; Self::Item;
    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn try_find&lt;F, R&gt;(
        &amp;mut self, 
        f: F
    ) -&gt; Result&lt;Option&lt;Self::Item&gt;, &lt;R as Try&gt;::Error&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; R,
        R: Try&lt;Ok = bool&gt;;
    fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        Self: ExactSizeIterator + DoubleEndedIterator,
        P: FnMut(Self::Item) -&gt; bool;
    fn max(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn min(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn max_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn min_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn rev(self) -&gt; Rev&lt;Self&gt;
    where
        Self: DoubleEndedIterator;
    fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)
    where
        Self: Iterator&lt;Item = (A, B)&gt;,
        FromA: Default + Extend&lt;A&gt;,
        FromB: Default + Extend&lt;B&gt;;
    fn copied&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Copy;
    fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Clone;
    fn cycle(self) -&gt; Cycle&lt;Self&gt;
    where
        Self: Clone;
    fn sum&lt;S&gt;(self) -&gt; S
    where
        S: Sum&lt;Self::Item&gt;;
    fn product&lt;P&gt;(self) -&gt; P
    where
        P: Product&lt;Self::Item&gt;;
    fn cmp&lt;I&gt;(self, other: I) -&gt; Ordering
    where
        I: IntoIterator&lt;Item = Self::Item&gt;,
        Self::Item: Ord;
    fn cmp_by&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Ordering
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering,
        I: IntoIterator;
    fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn partial_cmp_by&lt;I, F&gt;(
        self, 
        other: I, 
        partial_cmp: F
    ) -&gt; Option&lt;Ordering&gt;
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,
        I: IntoIterator;
    fn eq&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn eq_by&lt;I, F&gt;(self, other: I, eq: F) -&gt; bool
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool,
        I: IntoIterator;
    fn ne&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn lt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn le&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn gt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn ge&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn is_sorted(self) -&gt; bool
    where
        Self::Item: PartialOrd&lt;Self::Item&gt;;
    fn is_sorted_by&lt;F&gt;(self, compare: F) -&gt; bool
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Option&lt;Ordering&gt;;
    fn is_sorted_by_key&lt;F, K&gt;(self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; K,
        K: PartialOrd&lt;K&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>Iterator&lt;Item = T&gt;</code>类型可以被迭代并产生<code>T</code>类型。没有<code>IteratorMut</code> trait。每个<code>Iterator</code>实现可以指定它返回的是不可变引用、可变引用还是拥有通过<code>Item</code>关联类型的值。</p>
<table><thead><tr><th><code>Vec&lt;T&gt;</code> 方法</th><th>返回</th></tr></thead><tbody>
<tr><td><code>.iter()</code></td><td><code>Iterator&lt;Item = &amp;T&gt;</code></td></tr>
<tr><td><code>.iter_mut()</code></td><td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td></tr>
<tr><td><code>.into_iter()</code></td><td><code>Iterator&lt;Item = T&gt;</code></td></tr>
</tbody></table>
<p>大多数类型没有它们自己的迭代器，这对于初级Rustaceans来说，并不明显，但中级Rustaceans认为这是理所当然的。如果一个类型是可迭代的，我们几乎总是实现自定义的迭代器类型来迭代它，而不是让它自己迭代。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct MyType {
    items: Vec&lt;String&gt;
}

impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        MyTypeIterator {
            index: 0,
            items: &amp;self.items
        }
    }
}

struct MyTypeIterator&lt;'a&gt; {
    index: usize,
    items: &amp;'a Vec&lt;String&gt;
}

impl&lt;'a&gt; Iterator for MyTypeIterator&lt;'a&gt; {
    type Item = &amp;'a String;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.index &gt;= self.items.len() {
            None
        } else {
            let item = &amp;self.items[self.index];
            self.index += 1;
            Some(item)
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>为了便于教学，上面的例子展示了如何从头开始实现一个迭代器，但在这种情况下，常用的解决方案是直接延用<code>Vec</code>的<code>iter</code>方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType {
    items: Vec&lt;String&gt;
}

impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        self.items.iter()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>而且，这也是一个需要注意到的generic blanket impl：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;I: Iterator + ?Sized&gt; Iterator for &amp;mut I;
<span class="boring">}
</span></code></pre></pre>
<p>一个迭代器的可变引用也是一个迭代器。知道这一点是有用的，因为它让我们能够使用<code>self</code>作为接收器（receiver）的迭代器方法，就像<code>&amp;mut self</code>接收器一样。</p>
<p>举个例子，假定我们有一个函数，它处理一个数据超过三项的迭代器，但是函数的第一步是取出迭代器的前三项并在迭代完剩余项之前单独处理它们，下面是一个初学者可能会写出的函数实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.take(3).collect();
    for item in iter { // ❌ iter consumed in line above
        // process remaining items
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>这看起来有点让人头疼。<code>take</code>方法有一个<code>self</code>接收器，所以我们似乎不能在没有消耗整个迭代器的情况下调用它！下面是对上面代码的重构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = vec![
        iter.next().unwrap(),
        iter.next().unwrap(),
        iter.next().unwrap(),
    ];
    for item in iter { // ✅
        // process remaining items
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样是没问题的，但是实际中通常会这样重构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.by_ref().take(3).collect();
    for item in iter { // ✅
        // process remaining items
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种写法不太常见，但不管怎样，现在我们知道了。</p>
<p>此外，对于什么类型可以或者不可以是迭代器，并没有规则或者约定。如果一个类型实现了<code>Iterator</code>，那么它就是一个迭代器。下面是标准库中一个新颖的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;
use std::thread;

fn paths_can_be_iterated(path: &amp;Path) {
    for part in path {
        // iterate over parts of a path
    }
}

fn receivers_can_be_iterated() {
    let (send, recv) = channel();

    thread::spawn(move || {
        send.send(1).unwrap();
        send.send(2).unwrap();
        send.send(3).unwrap();
    });

    for received in recv {
        // iterate over received values
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#intoiterator" id="intoiterator">IntoIterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator 
where
    &lt;Self::IntoIter as Iterator&gt;::Item == Self::Item, 
{
    type Item;
    type IntoIter: Iterator;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>正如其名，<code>IntoIterator</code>类型可以转化为迭代器。当一个类型在一个<code>for-in</code>循环里被使用的时候，该类型的<code>into_iter</code>方法会被调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vec = Vec&lt;T&gt;
for v in vec {} // v = T

// above line desugared
for v in vec.into_iter() {}
<span class="boring">}
</span></code></pre></pre>
<p>不仅<code>Vec</code>实现了<code>IntoIterator</code>，如果我们想在不可变引用或可变引用上迭代，<code>&amp;Vec</code>和<code>&amp;mut Vec</code>同样也是如此。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vec = Vec&lt;T&gt;
for v in &amp;vec {} // v = &amp;T

// above example desugared
for v in (&amp;vec).into_iter() {}

// vec = Vec&lt;T&gt;
for v in &amp;mut vec {} // v = &amp;mut T

// above example desugared
for v in (&amp;mut vec).into_iter() {}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fromiterator" id="fromiterator">FromIterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromIterator&lt;A&gt; {
    fn from_iter&lt;T&gt;(iter: T) -&gt; Self
    where
        T: IntoIterator&lt;Item = A&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p>正如其名，<code>FromIterator</code>类型可以从一个迭代器创建而来。<code>FromIterator</code>最常用于<code>Iterator</code>上的<code>collect</code>方法调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;;

<span class="boring">}
</span></code></pre></pre>
<p>下面是一个例子，搜集（collect）一个<code>Iterator&lt;Item = char&gt;</code> 到 <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_letters(string: &amp;str) -&gt; String {
    string.chars().filter(|c| c.is_alphabetic()).collect()
}

<span class="boring">}
</span></code></pre></pre>
<p>标准库中所有的集合都实现了<code>IntoIterator</code>和<code>FromIterator</code>，从而使它们之间的转换更为简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{BTreeSet, HashMap, HashSet, LinkedList};

// String -&gt; HashSet&lt;char&gt;
fn unique_chars(string: &amp;str) -&gt; HashSet&lt;char&gt; {
    string.chars().collect()
}

// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
fn ordered_unique_items&lt;T: Ord&gt;(vec: Vec&lt;T&gt;) -&gt; BTreeSet&lt;T&gt; {
    vec.into_iter().collect()
}

// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
fn entry_list&lt;K, V&gt;(map: HashMap&lt;K, V&gt;) -&gt; LinkedList&lt;(K, V)&gt; {
    map.into_iter().collect()
}

// and countless more possible examples

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#io-traits" id="io-traits">I/O Traits</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    // provided default impls
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    unsafe fn initializer(&amp;self) -&gt; Initializer;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;;
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;;
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized;
    fn bytes(self) -&gt; Bytes&lt;Self&gt;
    where
        Self: Sized;
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
    where
        Self: Sized;
    fn take(self, limit: u64) -&gt; Take&lt;Self&gt;
    where
        Self: Sized;
}

trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    // provided default impls
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt;;
    fn is_write_vectored(&amp;self) -&gt; bool;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt;;
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized;
}

<span class="boring">}
</span></code></pre></pre>
<p>值得关注的generic blanket impls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;R: Read + ?Sized&gt; Read for &amp;mut R;
impl&lt;W: Write + ?Sized&gt; Write for &amp;mut W;

<span class="boring">}
</span></code></pre></pre>
<p>也就是说，<code>Read</code>类型的任何可变引用也都是<code>Read</code>，<code>Write</code>同理。知道这些是有用的，因为它允许我们使用任何带有<code>self</code>接收器的方法，就像它有一个<code>&amp;mut self</code>接收器一样。我们已经在迭代器trait部分讲过了它是如何起作用的以及为什么很有用，所以这里不再赘述。</p>
<p>这里我想指出的是，<code>&amp;[u8]</code> 实现了<code>Read</code>，<code>Vec&lt;u8&gt;</code>实现了<code>Write</code>。因此我们可以对我们的文件处理函数进行简单的单元测试，通过使用<code>String</code>转换为<code>&amp;[u8]</code>以及从<code>Vec&lt;u8&gt;</code> 转换为<code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::io;

// function we want to test
fn uppercase&lt;R: Read, W: Write&gt;(mut read: R, mut write: W) -&gt; Result&lt;(), io::Error&gt; {
    let mut buffer = String::new();
    read.read_to_string(&amp;mut buffer)?;
    let uppercase = buffer.to_uppercase();
    write.write_all(uppercase.as_bytes())?;
    write.flush()?;
    Ok(())
}

// in actual program we'd pass Files
fn example(in_path: &amp;Path, out_path: &amp;Path) -&gt; Result&lt;(), io::Error&gt; {
    let in_file = File::open(in_path)?;
    let out_file = File::open(out_path)?;
    uppercase(in_file, out_file)
}


// however in unit tests we can use Strings!
#[test] // ✅
fn example_test() {
    let in_file: String = &quot;i am screaming&quot;.into();
    let mut out_file: Vec&lt;u8&gt; = Vec::new();
    uppercase(in_file.as_bytes(), &amp;mut out_file).unwrap();
    let out_result = String::from_utf8(out_file).unwrap();
    assert_eq!(out_result, &quot;I AM SCREAMING&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p>我们一起学到了很多! 事实上是太多了。这是我们现在的样子：</p>
<p><img src="https://gitee.com/praying/picbed/raw/master/2021-7-25/1627191055521-image.png" alt="" /></p>

                    </main>

                    <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2021"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../chapter_7/learn.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../chapter_7/coercion_in_rust.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../chapter_7/learn.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../chapter_7/coercion_in_rust.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-188947685-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../mermaid-init.js"></script>
        
        <script type="text/javascript" src="../smart-anchor.js"></script>
        

        
    </body>
</html>
